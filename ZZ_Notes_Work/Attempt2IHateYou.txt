 
    
    
    
    
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!                               AI STUFF                                        !
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
    #Use regex
    def spacy_job_description_filter(self):
        print("spacy_job_description_filter()")
        nlp = spacy.load("en_core_web_sm")
        job_description = re.sub(r'/W+', ' ', job_description)
        doc = nlp(job_description.lower())
        return ' '.join([])
    
    
    
    
    
    
    
    
    
    
    #TODO: Double check this .head && .head crap!!!
    def spacy_extract_headword_and_dependants(doc):
        print("spacy_extract_headword_and_dependants()")
        headword = ""
        dependants = []
        for token in doc:
            print(f"""
                  TOKEN: {token.text}
                  ====
                  {token.tag_ = }
                  {token.head.text = }
                  {token.dep_ = }
                  """)
            
            
            
            if token.head == "ROOT":
                headword = token.head.text
            elif token.dep_ in {"compund", "amoud", "attr"}:
                dependants.append(token.lemma_)
                #dependants.append(token.text)
        print(f"headword = {headword}")
        print(f"dependants = {dependants}")
        return headword, dependants
    
    def handle_custom_rules(self, label):
        for rule, keys in config.CUSTOM_RULES.items():
            if fuzz.partial_ratio(label.lower(), rule.lower()) > 80:
                return keys
        return None
    
    def get_matching_key(self, label):
        custom_rule = self.handle_custom_rules(label)
        if custom_rule:
            return custom_rule
        
        max_similarity = 0
        best_match = None
        
        for key in self.users_information.keys():
            similarity = fuzz.partial_ratio(label.lower(), key.lower())
            if similarity > max_similarity:
                max_similarity = similarity
                best_match = key
                
        if max_similarity > 80:
            return [best_match]
        
        return None
    
    #MAYBE: from fuzzywuzzy import process
    def spacy_handle_custom_rules(self, label):
        print("spacy_handle_custom_rules()")
        for rules, key in config.CUSTOM_RULES.items():
            print(f"rules = {rules.lower()}")
            print(f"key = {key.lower()}")
            print(f"label = {label.lower()}")
            print(f"fuzz.token_set_ratio(key.lower(), label.lower()) = {fuzz.token_set_ratio(key.lower(), label.lower())}")
            if fuzz.token_set_ratio(key.lower(), label.lower()) > 80:
                return key
        return None
    
    #! If no keys match but 1 was a maybe then get the keys value and compare it to the label && || its predefined values!!!!! 
    def get_matching_key_if_present(self, label, special_expected_user_input):
        if special_expected_user_input is not None:
            if special_expected_user_input == 'is_multiple_choice':
                best_match = []
        
        print("get_matching_key_if_present()")
        custom_rule = self.spacy_handle_custom_rules(label)
        if custom_rule:
            return custom_rule
        
        max_similarity = 0
        best_match = None
        
        for key in self.users_information.keys():
            similarity = fuzz.token_set_ratio(label.lower(), key.lower())
            if similarity > max_similarity:
                max_similarity = similarity
                best_match = key
                
        if max_similarity > 80:
            return [best_match]
        
        return None
    
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!                                                                               !
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
    # print("Form Input Details: ", end="")
    # print(f"Input {i}:")
    # print(f"  Label: {detail['label']}")
    # print(f"  Type: {detail['type']}")
    # print(f"  Values: {detail['values']}")
    # print(f"  Is Hidden: {detail['is_hidden']}")
    # print(f"  HTML: {detail['html']}")
    # print(f"  Dynamic: {detail['dynamic']}")
    # print(f"  Related Elements: {detail['related_elements']}")
    #------------------------------------------------------------------------------
    # ['text', 'email', 'password', 'select', 'radio', 'checkbox', 'textarea', 'button', 'file']
    #TODO: Compare label->key/label->value/values->key/values->value
    def is_special_case(self, input_data):
        expected_user_input = None
        label = input_data['type']
        if label in ['select', 'radio', 'checkbox', 'file']:  #NOT 'button' b/c that's just the Submit
            if label == 'select':
                select_element = self.browser.find_element(label)
                is_multiple_choice = select_element.get_attribute('multiple') is not None
                if is_multiple_choice is True:
                    expected_user_input = 'is_multiple_choice'
                elif is_multiple_choice is False:
                    pass
            elif label == 'checkbox':
                expected_user_input = 'is_multiple_choice'
            elif label == 'file':
                expected_user_input = 'is_file'
        return expected_user_input

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    def ninety_percent_correct(self, form_question):
        stripper_string = form_question.strip()
        total_value = len(stripper_string)
        add_percent = 1 / total_value
        percent_correct = 0
        for word in form_question:
            for key_value in self.env_key_values:
                stripper_env = self.env_key_values.strip()
                for env_words in stripper_env:
                    percent_correct += add_percent
        if (.9 <= (percent_correct/total_value)):
            return True
        return False
    
    
    
    
    
    
    
    
    
    

    
    
    
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!                            FILLING IN FORM                                    !
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
    #TODO: .clear() ALL input tags before sending keys
    #TODO: v turn all the calls to this application_process() 
    def fill_out_application(self, job_link, form_input_details):
        #self.insert_resume()
        # form_data = self.get_form_input_details(job_link)
        # for form_input in form_data:
        #     question = form_input['label'].lower()
        #     input_type = form_input['type']
        #     predefined_values = form_input['values'].lower
        #     input_element_location = form_input['html']
            
        # #Final step
        # self.scroll_to_element()
        # form_data[:-1].click()
        #----------------------------------------------------------
        #self.process_form_input_details(form_input_details)
        #----------------------------------------------------------
        for input_data in form_input_details:
            label = input_data['label']
            matching_keys = self.get_matching_key_if_present(input_data, label)
            if matching_keys:
                answer = " ".join([self.users_information[key] for key in matching_keys])
            else:
                pass

    def process_form_input_details(self, form_input_details):
        nlp = spacy.load("en_core_web_sm")
        for input_detail in form_input_details:
            if not input_detail["is_hidden"] and input_detail["type"] != "submit":
                label = re.sub(r'/W+', ' ', input_detail['label'])
                doc = nlp(label.lower())
                #! JUST INSERT ROOT AS 1st INDEX!!!
                #TODO: Dependency Parse
                headword, dependants = self.spacy_extract_headword_and_dependants(doc)
                special_expected_user_input = self.is_special_case(input_detail)
                #if special_expected_user_input is not None:    #in ['is_multiple_chocie', 'is_file']:
                matching_keys = self.get_matching_key_if_present(label, special_expected_user_input)
                #value = self.match_env_value(input_detail)

                if value is None:
                    value = self.handle_special_cases(input_detail)
                    
                if matching_keys:
                    answer = " ".join([self.users_information[key] for key in matching_keys])

                if value is None:
                    value = input(f"Please enter a value for '{input_detail['label']}': ")
                    # Save the new value in the users_information dictionary
                    key = input_detail["label"].upper().replace(" ", "_")
                    self.users_information[key] = value
                    #TODO: Save to the config.py file
                    # Save the new value to the .env file
                    with open(self.env_path, "a") as file:
                        file.write(f"\n{key}='{value}'")

                # Input the value into the form (example with Selenium)
                field_name = input_detail["name"]
                field_element = self.driver.find_element_by_name(field_name)
                field_element.send_keys(value)

    def match_env_value(self, input_detail):
        label = input_detail["label"].upper().replace(" ", "_")
        for key, value in self.users_information.items():
            if key == label:
                return value
        return None

    def handle_special_cases(self, input_detail):
        standardized_label = self.standardize_string(input_detail["label"])

        # Add more special cases here as needed
        if self.is_yes_no_case(input_detail):
            env_value = self.find_matching_env_value(standardized_label)
            return self.handle_yes_no_case(input_detail, env_value)

        return None
    
    def is_yes_no_case(self, input_detail):
        standardized_label = self.standardize_string(input_detail["label"])
        yes_no_keywords = ["neurodiversity", "another_example"]  # Add more keywords as needed

        for keyword in yes_no_keywords:
            if keyword in standardized_label:
                return True

        return False

    def standardize_string(self, s):
        return s.lower().replace(" ", "_").replace("*", "").replace(".", "").replace("(", "").replace(")", "").replace("?", "")

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!                                                                               !
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #! ^^^ WARNINGS: 
        #NEGATIVES:
            # Only put your last name if you aren't Hispanic?
            # Kindly share your LinkedIn profile with us if you haven't already!
        #
        #BACKWARDS:
            #In my .env => 'ethnicity': 'mexico'  BUT  in form if label is 
        #ANSWERS DONT MATCH:
            #T/F => Y/N
        #
        #




 







    def find_visible_input(self, selector):
        input_element = self.browser.find_element(By.CSS_SELECTOR, selector)
        is_hidden = input_element.get_attribute('type') == 'hidden' or not input_element.is_displayed()
        if is_hidden:
            self.browser.execute_script("arguments[0].style.display = 'block';", input_element)
            is_hidden = input_element.get_attribute('type') == 'hidden' or not input_element.is_displayed()
        return input_element, not is_hidden 
        
    def is_input_invisible(self, input_element):
        from scraperGoogle import webdriver
        """
        Checks if an input element is invisible to the user
        Returns True if the input is invisible, False otherwise
        """
        if input_element is None:
            return False
        
        # Check if input element itself is hidden
        if input_element.get_attribute("type") == "hidden" or input_element.get_attribute("style") == "display: none;":
            return True
        
        # Check if parent element is hidden
        print(input_element)
        print(type(input_element))
        parent_element = input_element.find_element(By.XPATH, '..')
        while parent_element is not None:
            if parent_element.get_attribute("style") == "display: none;":
                return True
            parent_element = parent_element.find_element(By.XPATH, '..')
        return False



