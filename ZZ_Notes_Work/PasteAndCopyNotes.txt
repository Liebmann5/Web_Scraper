

I came across another form tag page that my code needs to work for.
[https://pastebin.com/UsHgaKi3]
Will my code still work for this form or will I have to make a few changes?















<input type="text" id="dev-field-1" name="dev_field_1" maxlength="255" autocomplete="off">




ok I believe I came across a bit of a special case I think find_and_organize_inputs() method is failing in this case. How would you change the method to best solve this issue and why?
<div class="field">
  <fieldset id="resume_fieldset" aria-describedby="validate_resume">
    <legend>
      <label aria-label="required" id="resume">
        Resume/CV <span class="asterisk">*</span>
      </label>
    </legend>
  
<div class="attach-or-paste " required="required" data-allow-s3="true" data-field="resume" data-file-types="[&quot;pdf&quot;,&quot;doc&quot;,&quot;docx&quot;,&quot;txt&quot;,&quot;rtf&quot;]" data-model="job_application">

  <div class="drop-zone hidden">
    Drop files here
  </div>

  <div id="resume_chosen" class="chosen">
    <img alt="resume chosen" src="https://boards.cdn.greenhouse.io/assets/file-296f4c2a42607d24e6901b7c58b0693d4178df7fe4edf1b50e9585efdfad7d39.png">&nbsp;&nbsp;
    <span id="resume_filename"></span>
    <button name="button" type="button" class="unstyled-button remove" aria-label="Remove attachment"><img width="11" height="11" alt="Remove attachment" src="https://boards.cdn.greenhouse.io/assets/cancellation/x-00cb7c69bded92bc90f03e0028a3457a4905b1e28c8a7fe16b792086c4288c29.png"></button>
</div>
  <div class="link-container">
    <button name="button" type="button" data-source="attach" class="unstyled-button link-button" aria-describedby="resume-allowable-file-types">Attach</button>

        <a data-source="dropbox" href="#">Dropbox</a>

        <a data-source="google-drive" href="#">Google Drive</a>

      <button name="button" type="button" data-source="paste" class="unstyled-button link-button" aria-pressed="false">or enter manually</button>
</div>  <div data-messages="uploaders"></div>

  <div class="validation-anchor" id="validate_resume" style="display: none"></div>
  <div id="resume-allowable-file-types" class="file-types">
    (File types: pdf, doc, docx, txt, rtf)
  </div>

  <div class="progress-bar">
    <div class="upload">
      <div class="progress"><div class="bar" style="width: 0%"></div></div>
    </div>
    <a href="#" class="cancel">
      <img width="11" height="11" alt="Cancel" src="https://boards.cdn.greenhouse.io/assets/cancellation/x-00cb7c69bded92bc90f03e0028a3457a4905b1e28c8a7fe16b792086c4288c29.png">
    </a>
</div>
    <textarea name="job_application[resume_text]" id="resume_text" class="paste" title="Enter manually"></textarea>

</div>

  </fieldset>
</div>
































    def find_and_organize_inputs(self, applic, soup):
        """
        Finds all the input elements in a form and returns a list of dictionaries
        containing information about each input.
        """
        form_inputs = []
        input_types = ["text", "email", "password", "number", "checkbox", "radio"]
        select_types = ["select"]
        textarea_types = ["textarea"]
        file_types = ["file"]
        input_elements = self.browser.find_elements(By.XPATH, "//form//input | //form//select | //form//textarea")
        for input_element in input_elements:
            input_type = input_element.get_attribute('type') or input_element.tag_name.lower()
            if input_type in input_types or input_type in select_types or input_type in textarea_types:
                input_label = ""
                input_values = []
                parent_element = input_element.find_element(By.XPATH, '..')
                while parent_element is not None:
                    try:
                        input_label_element = parent_element.find_element(By.XPATH, ".//label")
                        input_label = input_label_element.text.strip()
                        break
                    except NoSuchElementException:
                        parent_element = parent_element.find_element(By.XPATH, '..')
                if input_type in input_types:
                    if input_type == "checkbox":
                        if input_element.is_selected():
                            input_values.append(input_element.get_attribute('value'))
                    elif input_type == "radio":
                        radio_inputs = self.browser.find_elements(By.XPATH, "//form//input[@name='" + input_element.get_attribute('name') + "']")
                        radio_values = [radio.get_attribute('value') for radio in radio_inputs if radio.is_displayed()]
                        if radio_values:
                            input_values = radio_values
                    else:
                        input_values.append(input_element.get_attribute('value'))
                elif input_type in select_types:
                    select_options = input_element.find_elements(By.XPATH, ".//option")
                    input_values = [option.text.strip() for option in select_options]
                elif input_type in textarea_types:
                    input_values.append(input_element.get_attribute('value'))
                    
                is_hidden = input_element.get_attribute('type') == 'hidden' or not input_element.is_displayed()
                if is_hidden:
                    self.browser.execute_script("arguments[0].setAttribute('type', 'text');", input_element)
                    self.browser.execute_script("arguments[0].removeAttribute('style');", input_element)
                
                form_inputs.append({
                    "label": input_label,
                    "type": input_type,
                    "values": input_values,
                    "is_hidden": is_hidden
                })

        return form_inputs






























def find_and_organize_inputs(self, applic, soup):
    """
    Finds all the input elements in a form and returns a list of dictionaries
    containing information about each input.
    """
    self.browser.get(form['url'])
    form_inputs = []
    input_types = ["text", "email", "password", "number", "checkbox", "radio"]
    select_types = ["select"]
    textarea_types = ["textarea"]
    file_types = ["file"]
    input_elements = self.browser.find_elements_by_xpath("//form//input | //form//select | //form//textarea")
    
    for input_element in input_elements:
        input_type = input_element.get_attribute('type') or input_element.tag_name.lower()
        if input_type in input_types or input_type in select_types or input_type in textarea_types:
            input_label = ""
            input_values = []
            parent_element = input_element.find_element(By.XPATH, '..')
            while parent_element is not None:
                try:
                    input_label_element = parent_element.find_element(By.XPATH, ".//label")
                    input_label = input_label_element.text.strip()
                    break
                except NoSuchElementException:
                    parent_element = parent_element.find_element(By.XPATH, '..')
            if input_type in input_types:
                if input_type == "checkbox":
                    if input_element.is_selected():
                        input_values.append(input_element.get_attribute('value'))
                elif input_type == "radio":
                    radio_inputs = self.browser.find_elements_by_xpath("//form//input[@name='" + input_element.get_attribute('name') + "']")
                    radio_values = [radio.get_attribute('value') for radio in radio_inputs if radio.is_displayed()]
                    if radio_values:
                        input_values = radio_values
                else:
                    input_values.append(input_element.get_attribute('value'))
            elif input_type in select_types:
                select_options = input_element.find_elements(By.XPATH, ".//option")
                input_values = [option.text.strip() for option in select_options]
            elif input_type in textarea_types:
                input_values.append(input_element.get_attribute('value'))
                
            is_hidden = input_element.get_attribute('type') == 'hidden' or not input_element.is_displayed()
            if is_hidden:
                self.browser.execute_script("arguments[0].setAttribute('type', 'text');", input_element)
                self.browser.execute_script("arguments[0].removeAttribute('style');", input_element)
            
            form_inputs.append({
                "label": input_label,
                "type": input_type,
                "values": input_values,
                "is_hidden": is_hidden
            })
            
    return form_inputs











Have you ever worked for a Sony company previously?*
--
Yes
No
Are you authorized to work in the United States? * 
Please select
Yes
No
Will you now, or in the future, require sponsorship to work in the United States? *
--
Yes
No
Will you need relocation assistance to work at this role's specified location? * 
--
Yes
No
Are you related to, or in a shared housing situation with, anyone who currently works for SIE or any SIE-affiliated studios? *
--
Yes
No
By selecting "Yes", I am certifying that, to the best of my knowledge, the information I have provided in this employment application is true and correct. *
--
Yes
No
Gender
Please select
Yes
No
Decline To Self Identify
Are you Hispanic/Latino?
Please select
Yes
No
Decline To Self Identify
​Veteran Status​
Please select
​I am not a protected veteran
​I identify as one or more of the classifications of a protected veteran​
​I don't wish to answer
​Disability Status​
​Please select​
​Yes, I have a disability, or have a history/record of having a disability​
​No, I don't have a disability, or a history/record of having a disability
​I don't wish to answer

































Form Input Details:
Input 1:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="given-name" id="first_name" maxlength="255" name="job_application[first_name]" type="text"/>
Input 2:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="family-name" id="last_name" maxlength="255" name="job_application[last_name]" type="text"/>
Input 3:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="email" id="email" maxlength="255" name="job_application[email]" type="text"/>
Input 4:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="tel" id="phone" maxlength="255" name="job_application[phone]" required="required" type="text"/>
Input 5:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input autocomplete="off" id="dev-field-1" maxlength="255" name="dev_field_1" type="text"/>
Input 6:
  Label: Remove attachment
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-label="Remove attachment" class="unstyled-button remove" name="button" type="button"><img alt="Remove attachment" height="11" src="https://boards.cdn.greenhouse.io/assets/cancellation/x-00cb7c69bded92bc90f03e0028a3457a4905b1e28c8a7fe16b792086c4288c29.png" width="11"/></button>
Input 7:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-describedby="resume-allowable-file-types" class="unstyled-button link-button" data-source="attach" name="button" type="button">Attach</button>
Input 8:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-pressed="false" class="unstyled-button link-button" data-source="paste" name="button" type="button">or enter manually</button>
Input 9:
  Label: Enter manually
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="paste" id="resume_text" name="job_application[resume_text]" title="Enter manually">
</textarea>
Input 10:
  Label: Remove attachment
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-label="Remove attachment" class="unstyled-button remove" name="button" type="button"><img alt="Remove attachment" height="11" src="https://boards.cdn.greenhouse.io/assets/cancellation/x-00cb7c69bded92bc90f03e0028a3457a4905b1e28c8a7fe16b792086c4288c29.png" width="11"/></button>
Input 11:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-describedby="cover_letter-allowable-file-types" class="unstyled-button link-button" data-source="attach" name="button" type="button">Attach</button>
Input 12:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-pressed="false" class="unstyled-button link-button" data-source="paste" name="button" type="button">or enter manually</button>
Input 13:
  Label: Enter manually
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="paste" id="cover_letter_text" name="job_application[cover_letter_text]" title="Enter manually">
</textarea>
Input 14:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="false" autocomplete="custom-question-linkedin-profile" id="job_application_answers_attributes_0_text_value" maxlength="255" name="job_application[answers_attributes][0][text_value]" type="text"/>
Input 15:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="false" autocomplete="custom-question-website" id="job_application_answers_attributes_1_text_value" maxlength="255" name="job_application[answers_attributes][1][text_value]" type="text"/>
Input 16:
  Label:
  Type: select
  Values: ['--', 'Yes', 'No']
  Is Hidden: False
  HTML: <select aria-required="true" id="job_application_answers_attributes_2_boolean_value" name="job_application[answers_attributes][2][boolean_value]"><option value="">--</option>
<option value="1">Yes</option>
<option value="0">No</option></select>
Input 17:
  Label:
  Type: select
  Values: ['--', 'Yes', 'No']
  Is Hidden: False
  HTML: <select aria-required="true" id="job_application_answers_attributes_3_boolean_value" name="job_application[answers_attributes][3][boolean_value]"><option value="">--</option>
<option value="1">Yes</option>
<option value="0">No</option></select>
Input 18:
  Label:
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea aria-required="true" autocomplete="custom-question-where-did-you-first-learn-about-this-opportunity-if-you-were-referred-please-note-individuals-name" id="job_application_answers_attributes_4_text_value" name="job_application[answers_attributes][4][text_value]">
</textarea>
Input 19:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="custom-question-what-are-your-compensation-expectations-for-this-role" id="job_application_answers_attributes_5_text_value" maxlength="255" name="job_application[answers_attributes][5][text_value]" type="text"/>
Input 20:
  Label:
  Type: select
  Values: ['Please select', 'Male', 'Female', 'Decline To Self Identify']
  Is Hidden: False
  HTML: <select id="job_application_gender" name="job_application[gender]"><option value="">Please select</option><option value="1">Male</option>
<option value="2">Female</option>
<option value="3">Decline To Self Identify</option></select>
Input 21:
  Label:
  Type: select
  Values: ['Please select', 'Yes', 'No', 'Decline To Self Identify']
  Is Hidden: False
  HTML: <select id="job_application_hispanic_ethnicity" name="job_application[hispanic_ethnicity]"><option value="">Please select</option><option value="Yes">Yes</option>
<option value="No">No</option>
<option value="Decline To Self Identify">Decline To Self Identify</option></select>
Input 22:
  Label:
  Type: select
  Values: ['Please select', 'American Indian or Alaskan Native', 'Asian', 'Black or African American', 'Hispanic or Latino', 'White', 'Native Hawaiian or Other Pacific Islander', 'Two or More Races', 'Decline To Self Identify']
  Is Hidden: False
  HTML: <select id="job_application_race" name="job_application[race]"><option value="">Please select</option><option value="1">American Indian or Alaskan Native</option>
<option value="2">Asian</option>
<option value="3">Black or African American</option>
<option hidden="hidden" value="4">Hispanic or Latino</option>
<option value="5">White</option>
<option value="6">Native Hawaiian or Other Pacific Islander</option>
<option value="7">Two or More Races</option>
<option value="8">Decline To Self Identify</option></select>
Input 23:
  Label:
  Type: select
  Values: ['Please select', 'I am not a protected veteran', 'I identify as one or more of the classifications of a protected veteran', "I don't wish to answer"]
  Is Hidden: False
  HTML: <select id="job_application_veteran_status" name="job_application[veteran_status]"><option value="">Please select</option><option value="1">I am not a protected veteran</option>
<option value="2">I identify as one or more of the classifications of a protected veteran</option>
<option value="3">I don't wish to answer</option></select>
Input 24:
  Label:
  Type: select
  Values: ['Please select', 'Yes, I have a disability, or have a history/record of having a disability', "No, I don't have a disability, or a history/record of having a disability", "I don't wish to answer"]
  Is Hidden: False
  HTML: <select id="job_application_disability_status" name="job_application[disability_status]"><option value="">Please select</option><option value="1">Yes, I have a disability, or have a history/record of having a disability</option>
<option value="2">No, I don't have a disability, or a history/record of having a disability</option>
<option value="3">I don't wish to answer</option></select>
Input 25:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <input class="button" id="submit_app" type="button" value="Submit Application"/>
Input 26:
  Label: Select a School
  Type: hidden
  Values: []
  Is Hidden: True
  HTML: <input aria-required="false" class="school-name background-field" data-url="https://boards-api.greenhouse.io/v1/boards/doubleverify/education/schools" data-validators='[{"type":"notBlank","key":"SchoolNameRequired"}]' id="education_school_name" name="job_application[educations][][school_name_id]" placeholder="Select a School" type="hidden">
<a class="remove-background-field" href="#"><img alt="Remove Education" src="https://boards.cdn.greenhouse.io/assets/svg/close-2388e0f798509ffdefd9fe48321955a399f62a302d4f33f96e798f2272a7b52d.svg"/></a>    
</input>
Input 27:
  Label:
  Type: select
  Values: ['', 'High School', "Associate's Degree", "Bachelor's Degree", "Master's Degree", 'Master of Business Administration (M.B.A.)', 'Juris Doctor (J.D.)', 'Doctor of Medicine (M.D.)', 'Doctor of Philosophy (Ph.D.)', "Engineer's Degree", 'Other']
  Is Hidden: False
  HTML: <select aria-required="false" class="degree background-field" data-placeholder="Select a Degree" data-validators='[{"type":"notBlank","key":"DegreeRequired"}]' id="education_degree" name="job_application[educations][][degree_id]"><option value=""></option>
<option value="5387323002">High School</option>
<option value="5387324002">Associate's Degree</option>
<option value="5387325002">Bachelor's Degree</option>
<option value="5387326002">Master's Degree</option>
<option value="5387327002">Master of Business Administration (M.B.A.)</option>
<option value="5387328002">Juris Doctor (J.D.)</option>
<option value="5387329002">Doctor of Medicine (M.D.)</option>
<option value="5387330002">Doctor of Philosophy (Ph.D.)</option>
<option value="5387331002">Engineer's Degree</option>
<option value="5387332002">Other</option></select>
Input 28:
  Label:
  Type: select
  Values: ['', 'Accounting', 'African Studies', 'Agriculture', 'Anthropology', 'Applied Health Services', 'Architecture', 'Art', 'Asian Studies', 'Biology', 'Business', 'Business Administration', 'Chemistry', 'Classical Languages', 'Communications & Film', 'Computer Science', 'Dentistry', 'Developing Nations', 'Discipline Unknown', 'Earth Sciences', 'Economics', 'Education', 'Electronics', 'Engineering', 'English Studies', 'Environmental Studies', 'European Studies', 'Fashion', 'Finance', 'Fine Arts', 'General Studies', 'Health Services', 'History', 'Human Resources Management', 'Humanities', 'Industrial Arts & Carpentry', 'Information Systems', 'International Relations', 'Journalism', 'Languages', 'Latin American Studies', 'Law', 'Linguistics', 'Manufacturing & Mechanics', 'Mathematics', 'Medicine', 'Middle Eastern Studies', 'Naval Science', 'North American Studies', 'Nuclear Technics', 'Operations Research & Strategy', 'Organizational Theory', 'Philosophy', 'Physical Education', 'Physical Sciences', 'Physics', 'Political Science', 'Psychology', 'Public Policy', 'Public Service', 'Religious Studies', 'Russian & Soviet Studies', 'Scandinavian Studies', 'Science', 'Slavic Studies', 'Social Science', 'Social Sciences', 'Sociology', 'Speech', 'Statistics & Decision Theory', 'Urban Studies', 'Veterinary Medicine', 'Other']
  Is Hidden: False
  HTML: <select aria-required="false" class="discipline background-field" data-placeholder="Select a Discipline" data-validators='[{"type":"notBlank","key":"DisciplineRequired"}]' id="education_discipline" name="job_application[educations][][discipline_id]"><option value=""></option>
<option value="5387333002">Accounting</option>
<option value="5387334002">African Studies</option>
<option value="5387335002">Agriculture</option>
<option value="5387336002">Anthropology</option>
<option value="5387337002">Applied Health Services</option>
<option value="5387338002">Architecture</option>
<option value="5387339002">Art</option>
<option value="5387340002">Asian Studies</option>
<option value="5387341002">Biology</option>
<option value="5387342002">Business</option>
<option value="5387343002">Business Administration</option>
<option value="5387344002">Chemistry</option>
<option value="5387345002">Classical Languages</option>
<option value="5387346002">Communications &amp; Film</option>
<option value="5387347002">Computer Science</option>
<option value="5387348002">Dentistry</option>
<option value="5387349002">Developing Nations</option>
<option value="5387350002">Discipline Unknown</option>
<option value="5387351002">Earth Sciences</option>
<option value="5387352002">Economics</option>
<option value="5387353002">Education</option>
<option value="5387354002">Electronics</option>
<option value="5387355002">Engineering</option>
<option value="5387356002">English Studies</option>
<option value="5387357002">Environmental Studies</option>
<option value="5387358002">European Studies</option>
<option value="5387359002">Fashion</option>
<option value="5387360002">Finance</option>
<option value="5387361002">Fine Arts</option>
<option value="5387362002">General Studies</option>
<option value="5387363002">Health Services</option>
<option value="5387364002">History</option>
<option value="5387365002">Human Resources Management</option>
<option value="5387366002">Humanities</option>
<option value="5387367002">Industrial Arts &amp; Carpentry</option>
<option value="5387368002">Information Systems</option>
<option value="5387369002">International Relations</option>
<option value="5387370002">Journalism</option>
<option value="5387371002">Languages</option>
<option value="5387372002">Latin American Studies</option>
<option value="5387373002">Law</option>
<option value="5387374002">Linguistics</option>
<option value="5387375002">Manufacturing &amp; Mechanics</option>
<option value="5387376002">Mathematics</option>
<option value="5387377002">Medicine</option>
<option value="5387378002">Middle Eastern Studies</option>
<option value="5387379002">Naval Science</option>
<option value="5387380002">North American Studies</option>
<option value="5387381002">Nuclear Technics</option>
<option value="5387382002">Operations Research &amp; Strategy</option>
<option value="5387383002">Organizational Theory</option>
<option value="5387384002">Philosophy</option>
<option value="5387385002">Physical Education</option>
<option value="5387386002">Physical Sciences</option>
<option value="5387387002">Physics</option>
<option value="5387388002">Political Science</option>
<option value="5387389002">Psychology</option>
<option value="5387390002">Public Policy</option>
<option value="5387391002">Public Service</option>
<option value="5387392002">Religious Studies</option>
<option value="5387393002">Russian &amp; Soviet Studies</option>
<option value="5387394002">Scandinavian Studies</option>
<option value="5387395002">Science</option>
<option value="5387396002">Slavic Studies</option>
<option value="5387397002">Social Science</option>
<option value="5387398002">Social Sciences</option>
<option value="5387399002">Sociology</option>
<option value="5387400002">Speech</option>
<option value="5387401002">Statistics &amp; Decision Theory</option>
<option value="5387402002">Urban Studies</option>
<option value="5387403002">Veterinary Medicine</option>
<option value="16771699002">Other</option></select>
Input 29:
  Label: Education Start Year
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-label="Education Start Year" aria-required="false" class="start-date-year year background-field" data-validators='[{"type":"yearFormat","key":"EducationYearFormat"}]' maxlength="4" name="job_application[educations][][start_date][year]" placeholder="YYYY" type="text"/>
Input 30:
  Label: Education End Year
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-label="Education End Year" aria-required="false" class="end-date-year year background-field" data-validators='[{"type":"yearFormat","key":"EducationYearFormat"}]' maxlength="4" name="job_application[educations][][end_date][year]" placeholder="YYYY" type="text"/>


You've done it all your hard work is done! Definitely wasn't worth it but whatever. Never doin that crap again.
D







































OH my gosh yes your method get_form_input_details() is almost perfect so this the response from the terminal
Form Input Details:
Input 1:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="given-name" id="first_name" maxlength="255" name="job_application[first_name]" type="text"/>
Input 2:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="family-name" id="last_name" maxlength="255" name="job_application[last_name]" type="text"/>
Input 3:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="email" id="email" maxlength="255" name="job_application[email]" type="text"/>
Input 4:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="tel" id="phone" maxlength="255" name="job_application[phone]" required="required" type="text"/>
Input 5:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input autocomplete="off" id="dev-field-1" maxlength="255" name="dev_field_1" type="text"/>
Input 6:
  Label: Remove attachment
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-label="Remove attachment" class="unstyled-button remove" name="button" type="button"><img alt="Remove attachment" height="11" src="https://boards.cdn.greenhouse.io/assets/cancellation/x-00cb7c69bded92bc90f03e0028a3457a4905b1e28c8a7fe16b792086c4288c29.png" width="11"/></button>
Input 7:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-describedby="resume-allowable-file-types" class="unstyled-button link-button" data-source="attach" name="button" type="button">Attach</button>
Input 8:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-pressed="false" class="unstyled-button link-button" data-source="paste" name="button" type="button">or enter manually</button>
Input 9:
  Label: Enter manually
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="paste" id="resume_text" name="job_application[resume_text]" title="Enter manually">
</textarea>
Input 10:
  Label: Remove attachment
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-label="Remove attachment" class="unstyled-button remove" name="button" type="button"><img alt="Remove attachment" height="11" src="https://boards.cdn.greenhouse.io/assets/cancellation/x-00cb7c69bded92bc90f03e0028a3457a4905b1e28c8a7fe16b792086c4288c29.png" width="11"/></button>
Input 11:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-describedby="cover_letter-allowable-file-types" class="unstyled-button link-button" data-source="attach" name="button" type="button">Attach</button>
Input 12:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button aria-pressed="false" class="unstyled-button link-button" data-source="paste" name="button" type="button">or enter manually</button>
Input 13:
  Label: Enter manually
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="paste" id="cover_letter_text" name="job_application[cover_letter_text]" title="Enter manually">
</textarea>
Input 14:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="false" autocomplete="custom-question-linkedin-profile" id="job_application_answers_attributes_0_text_value" maxlength="255" name="job_application[answers_attributes][0][text_value]" type="text"/>
Input 15:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="false" autocomplete="custom-question-website" id="job_application_answers_attributes_1_text_value" maxlength="255" name="job_application[answers_attributes][1][text_value]" type="text"/>
Input 16:
  Label:
  Type: select
  Values: ['--', 'Yes', 'No']
  Is Hidden: False
  HTML: <select aria-required="true" id="job_application_answers_attributes_2_boolean_value" name="job_application[answers_attributes][2][boolean_value]"><option value="">--</option>
<option value="1">Yes</option>
<option value="0">No</option></select>
Input 17:
  Label:
  Type: select
  Values: ['--', 'Yes', 'No']
  Is Hidden: False
  HTML: <select aria-required="true" id="job_application_answers_attributes_3_boolean_value" name="job_application[answers_attributes][3][boolean_value]"><option value="">--</option>
<option value="1">Yes</option>
<option value="0">No</option></select>
Input 18:
  Label:
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea aria-required="true" autocomplete="custom-question-where-did-you-first-learn-about-this-opportunity-if-you-were-referred-please-note-individuals-name" id="job_application_answers_attributes_4_text_value" name="job_application[answers_attributes][4][text_value]">
</textarea>
Input 19:
  Label:
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-required="true" autocomplete="custom-question-what-are-your-compensation-expectations-for-this-role" id="job_application_answers_attributes_5_text_value" maxlength="255" name="job_application[answers_attributes][5][text_value]" type="text"/>
Input 20:
  Label:
  Type: select
  Values: ['Please select', 'Male', 'Female', 'Decline To Self Identify']
  Is Hidden: False
  HTML: <select id="job_application_gender" name="job_application[gender]"><option value="">Please select</option><option value="1">Male</option>
<option value="2">Female</option>
<option value="3">Decline To Self Identify</option></select>
Input 21:
  Label:
  Type: select
  Values: ['Please select', 'Yes', 'No', 'Decline To Self Identify']
  Is Hidden: False
  HTML: <select id="job_application_hispanic_ethnicity" name="job_application[hispanic_ethnicity]"><option value="">Please select</option><option value="Yes">Yes</option>
<option value="No">No</option>
<option value="Decline To Self Identify">Decline To Self Identify</option></select>
Input 22:
  Label:
  Type: select
  Values: ['Please select', 'American Indian or Alaskan Native', 'Asian', 'Black or African American', 'Hispanic or Latino', 'White', 'Native Hawaiian or Other Pacific Islander', 'Two or More Races', 'Decline To Self Identify']
  Is Hidden: False
  HTML: <select id="job_application_race" name="job_application[race]"><option value="">Please select</option><option value="1">American Indian or Alaskan Native</option>
<option value="2">Asian</option>
<option value="3">Black or African American</option>
<option hidden="hidden" value="4">Hispanic or Latino</option>
<option value="5">White</option>
<option value="6">Native Hawaiian or Other Pacific Islander</option>
<option value="7">Two or More Races</option>
<option value="8">Decline To Self Identify</option></select>
Input 23:
  Label:
  Type: select
  Values: ['Please select', 'I am not a protected veteran', 'I identify as one or more of the classifications of a protected veteran', "I don't wish to answer"]
  Is Hidden: False
  HTML: <select id="job_application_veteran_status" name="job_application[veteran_status]"><option value="">Please select</option><option value="1">I am not a protected veteran</option>
<option value="2">I identify as one or more of the classifications of a protected veteran</option>
<option value="3">I don't wish to answer</option></select>
Input 24:
  Label:
  Type: select
  Values: ['Please select', 'Yes, I have a disability, or have a history/record of having a disability', "No, I don't have a disability, or a history/record of having a disability", "I don't wish to answer"]
  Is Hidden: False
  HTML: <select id="job_application_disability_status" name="job_application[disability_status]"><option value="">Please select</option><option value="1">Yes, I have a disability, or have a history/record of having a disability</option>
<option value="2">No, I don't have a disability, or a history/record of having a disability</option>
<option value="3">I don't wish to answer</option></select>
Input 25:
  Label:
  Type: button
  Values: []
  Is Hidden: False
  HTML: <input class="button" id="submit_app" type="button" value="Submit Application"/>
Input 26:
  Label: Select a School
  Type: hidden
  Values: []
  Is Hidden: True
  HTML: <input aria-required="false" class="school-name background-field" data-url="https://boards-api.greenhouse.io/v1/boards/doubleverify/education/schools" data-validators='[{"type":"notBlank","key":"SchoolNameRequired"}]' id="education_school_name" name="job_application[educations][][school_name_id]" placeholder="Select a School" type="hidden">
<a class="remove-background-field" href="#"><img alt="Remove Education" src="https://boards.cdn.greenhouse.io/assets/svg/close-2388e0f798509ffdefd9fe48321955a399f62a302d4f33f96e798f2272a7b52d.svg"/></a>    
</input>
Input 27:
  Label:
  Type: select
  Values: ['', 'High School', "Associate's Degree", "Bachelor's Degree", "Master's Degree", 'Master of Business Administration (M.B.A.)', 'Juris Doctor (J.D.)', 'Doctor of Medicine (M.D.)', 'Doctor of Philosophy (Ph.D.)', "Engineer's Degree", 'Other']
  Is Hidden: False
  HTML: <select aria-required="false" class="degree background-field" data-placeholder="Select a Degree" data-validators='[{"type":"notBlank","key":"DegreeRequired"}]' id="education_degree" name="job_application[educations][][degree_id]"><option value=""></option>
<option value="5387323002">High School</option>
<option value="5387324002">Associate's Degree</option>
<option value="5387325002">Bachelor's Degree</option>
<option value="5387326002">Master's Degree</option>
<option value="5387327002">Master of Business Administration (M.B.A.)</option>
<option value="5387328002">Juris Doctor (J.D.)</option>
<option value="5387329002">Doctor of Medicine (M.D.)</option>
<option value="5387330002">Doctor of Philosophy (Ph.D.)</option>
<option value="5387331002">Engineer's Degree</option>
<option value="5387332002">Other</option></select>
Input 28:
  Label:
  Type: select
  Values: ['', 'Accounting', 'African Studies', 'Agriculture', 'Anthropology', 'Applied Health Services', 'Architecture', 'Art', 'Asian Studies', 'Biology', 'Business', 'Business Administration', 'Chemistry', 'Classical Languages', 'Communications & Film', 'Computer Science', 'Dentistry', 'Developing Nations', 'Discipline Unknown', 'Earth Sciences', 'Economics', 'Education', 'Electronics', 'Engineering', 'English Studies', 'Environmental Studies', 'European Studies', 'Fashion', 'Finance', 'Fine Arts', 'General Studies', 'Health Services', 'History', 'Human Resources Management', 'Humanities', 'Industrial Arts & Carpentry', 'Information Systems', 'International Relations', 'Journalism', 'Languages', 'Latin American Studies', 'Law', 'Linguistics', 'Manufacturing & Mechanics', 'Mathematics', 'Medicine', 'Middle Eastern Studies', 'Naval Science', 'North American Studies', 'Nuclear Technics', 'Operations Research & Strategy', 'Organizational Theory', 'Philosophy', 'Physical Education', 'Physical Sciences', 'Physics', 'Political Science', 'Psychology', 'Public Policy', 'Public Service', 'Religious Studies', 'Russian & Soviet Studies', 'Scandinavian Studies', 'Science', 'Slavic Studies', 'Social Science', 'Social Sciences', 'Sociology', 'Speech', 'Statistics & Decision Theory', 'Urban Studies', 'Veterinary Medicine', 'Other']
  Is Hidden: False
  HTML: <select aria-required="false" class="discipline background-field" data-placeholder="Select a Discipline" data-validators='[{"type":"notBlank","key":"DisciplineRequired"}]' id="education_discipline" name="job_application[educations][][discipline_id]"><option value=""></option>
<option value="5387333002">Accounting</option>
<option value="5387334002">African Studies</option>
<option value="5387335002">Agriculture</option>
<option value="5387336002">Anthropology</option>
<option value="5387337002">Applied Health Services</option>
<option value="5387338002">Architecture</option>
<option value="5387339002">Art</option>
<option value="5387340002">Asian Studies</option>
<option value="5387341002">Biology</option>
<option value="5387342002">Business</option>
<option value="5387343002">Business Administration</option>
<option value="5387344002">Chemistry</option>
<option value="5387345002">Classical Languages</option>
<option value="5387346002">Communications &amp; Film</option>
<option value="5387347002">Computer Science</option>
<option value="5387348002">Dentistry</option>
<option value="5387349002">Developing Nations</option>
<option value="5387350002">Discipline Unknown</option>
<option value="5387351002">Earth Sciences</option>
<option value="5387352002">Economics</option>
<option value="5387353002">Education</option>
<option value="5387354002">Electronics</option>
<option value="5387355002">Engineering</option>
<option value="5387356002">English Studies</option>
<option value="5387357002">Environmental Studies</option>
<option value="5387358002">European Studies</option>
<option value="5387359002">Fashion</option>
<option value="5387360002">Finance</option>
<option value="5387361002">Fine Arts</option>
<option value="5387362002">General Studies</option>
<option value="5387363002">Health Services</option>
<option value="5387364002">History</option>
<option value="5387365002">Human Resources Management</option>
<option value="5387366002">Humanities</option>
<option value="5387367002">Industrial Arts &amp; Carpentry</option>
<option value="5387368002">Information Systems</option>
<option value="5387369002">International Relations</option>
<option value="5387370002">Journalism</option>
<option value="5387371002">Languages</option>
<option value="5387372002">Latin American Studies</option>
<option value="5387373002">Law</option>
<option value="5387374002">Linguistics</option>
<option value="5387375002">Manufacturing &amp; Mechanics</option>
<option value="5387376002">Mathematics</option>
<option value="5387377002">Medicine</option>
<option value="5387378002">Middle Eastern Studies</option>
<option value="5387379002">Naval Science</option>
<option value="5387380002">North American Studies</option>
<option value="5387381002">Nuclear Technics</option>
<option value="5387382002">Operations Research &amp; Strategy</option>
<option value="5387383002">Organizational Theory</option>
<option value="5387384002">Philosophy</option>
<option value="5387385002">Physical Education</option>
<option value="5387386002">Physical Sciences</option>
<option value="5387387002">Physics</option>
<option value="5387388002">Political Science</option>
<option value="5387389002">Psychology</option>
<option value="5387390002">Public Policy</option>
<option value="5387391002">Public Service</option>
<option value="5387392002">Religious Studies</option>
<option value="5387393002">Russian &amp; Soviet Studies</option>
<option value="5387394002">Scandinavian Studies</option>
<option value="5387395002">Science</option>
<option value="5387396002">Slavic Studies</option>
<option value="5387397002">Social Science</option>
<option value="5387398002">Social Sciences</option>
<option value="5387399002">Sociology</option>
<option value="5387400002">Speech</option>
<option value="5387401002">Statistics &amp; Decision Theory</option>
<option value="5387402002">Urban Studies</option>
<option value="5387403002">Veterinary Medicine</option>
<option value="16771699002">Other</option></select>
Input 29:
  Label: Education Start Year
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-label="Education Start Year" aria-required="false" class="start-date-year year background-field" data-validators='[{"type":"yearFormat","key":"EducationYearFormat"}]' maxlength="4" name="job_application[educations][][start_date][year]" placeholder="YYYY" type="text"/>
Input 30:
  Label: Education End Year
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input aria-label="Education End Year" aria-required="false" class="end-date-year year background-field" data-validators='[{"type":"yearFormat","key":"EducationYearFormat"}]' maxlength="4" name="job_application[educations][][end_date][year]" placeholder="YYYY" type="text"/>


You've done it all your hard work is done! Definitely wasn't worth it but whatever. Never doin that crap again.
D
so the purpose of the details variable is that every key and value is important information that I need to look through so I can compare it to the values I have available and insert the best value option if I don't have a value that is equal to a present option; like a real user who is filling out this form would do! So I'll explain why and what each variable does in the rest of my code. So the key 'label' doesn't necessarily correlate to the label tag, if present at all, in the form HTML. My 'label' key should return the string or anything that tells the user what information is needed for that box. The 'type' key should tell me how the box is setup for the user to input that information which is because once I have found a suitable value, I can prepare Selenium to the best of my abilities how it would input or choose the corresponding value the exact way a user would; as an example maybe click radio buttons or select the value from a drop down menu or insert text into a textarea. The 'values' key is very important because most of the time in a form, a user is restricted to only a select number of values which means that if I have a value that is not present in those options then I need to find the best possible value from the available values from the specific form field. The 'Is_Hidden' key was just for me to learn so not very important. Finally, the 'HTML' key is very important. I may be wrong in this way of thinking so if you know of a better way to go about this then please tell me but this key's purpose is just how I can quickly tell selenium exactly where to go in the form to insert the value. Now knowing the purpose of this method and knowing this has to work for all possible how and what would you change in my method to make this possible if not better?












































Input 19:
  Label: Race
  Type: radio
  Values: ['Hispanic or Latino', 'White (Not Hispanic or Latino)', 'Black or African American (Not Hispanic or Latino)', 'Native Hawaiian or Other Pacific Islander (Not Hispanic or Latino)', 'Asian (Not Hispanic or Latino)', 'American Indian or Alaska Native (Not Hispanic or Latino)', 'Two or More Races (Not Hispanic or Latino)', 'Decline to self-identify']
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="Hispanic or Latino"/><input name="eeo[race]" type="radio" value="White (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="White (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Black or African American (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Native Hawaiian or Other Pacific Islander (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Asian (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="American Indian or Alaska Native (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Two or More Races (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Decline to self-identify"/>


That didn't work so this was the terminals output again
Input 19:
  Label: 
  Type: radio
  Values: []
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="Hispanic or Latino"/>
Input 20:
  Label: 
  Type: radio
  Values: []
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="White (Not Hispanic or Latino)"/>
Input 21:
  Label: 
  Type: radio
  Values: []
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="Black or African American (Not Hispanic or Latino)"/>
Input 22:
  Label: 
  Type: radio
  Values: []
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="Native Hawaiian or Other Pacific Islander (Not Hispanic or Latino)"/>
Input 23:
  Label: 
  Type: radio
  Values: []
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="Asian (Not Hispanic or Latino)"/>
Input 24:
  Label: 
  Type: radio
  Values: []
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="American Indian or Alaska Native (Not Hispanic or Latino)"/>
Input 25:
  Label: 
  Type: radio
  Values: []
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="Two or More Races (Not Hispanic or Latino)"/>
Input 26:
  Label: 
  Type: radio
  Values: []
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="Decline to self-identify"/>
but what what I'm looking for it to be is something like this
Input 19:
  Label: Race
  Type: radio
  Values: ['Hispanic or Latino', 'White (Not Hispanic or Latino)', 'Black or African American (Not Hispanic or Latino)', 'Native Hawaiian or Other Pacific Islander (Not Hispanic or Latino)', 'Asian (Not Hispanic or Latino)', 'American Indian or Alaska Native (Not Hispanic or Latino)', 'Two or More Races (Not Hispanic or Latino)', 'Decline to self-identify']
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="Hispanic or Latino"/><input name="eeo[race]" type="radio" value="White (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="White (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Black or African American (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Native Hawaiian or Other Pacific Islander (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Asian (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="American Indian or Alaska Native (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Two or More Races (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Decline to self-identify"/>

































What is your desired pay for this role? *








So this was a piece of what the terminal returned from that method
Input 12:
  Label: Type your response
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input class="card-field-input" name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field3]" placeholder="Type your response" required="required" type="text" value=""/>

Input 17:
  Label: Add a cover letter or anything else you want to share.
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea id="additional-information" name="comments" placeholder="Add a cover letter or anything else you want to share."></textarea>
and I'll put the code return that I'm looking for at the bottom. So Input 17: doesn't have any text above the box to tell the user what kind of information is needed. In these situations can you instead find the placeholder and retrieve its value and set that equl to the label key but to also signify when you do this add 'Placeholder ~ ' to the front of the value. So to clarify Input 17: in the return above is exactly what I want but I dont believe the method you gave does it in the way I'm looking for. Then a good example of what I'm looking for overall is Input 12:. In the terminal response it returned 'Type your response' for the label key value when it should've been 'What is your desired pay for this role? *'! But if 'What is your desired pay for this role? *' wasn't present then 'Type your response' would've been the value that I wanted. How would you change the method to resolve this issue?
Input 12:
  Label: What is your desired pay for this role? *
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input class="card-field-input" name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field3]" placeholder="Type your response" required="required" type="text" value=""/>

Input 17:
  Label: Placeholder ~ Add a cover letter or anything else you want to share.
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea id="additional-information" name="comments" placeholder="Add a cover letter or anything else you want to share."></textarea>






































Form Input Details:
Input 1:
  Label: LinkedIn profile
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button class="template-btn-utility awli-button state-loading" type="button"><div class="loading"><div class="icon loading-indicator small"></div><span class="awli-button-label">Loading</span></div><div class="ready"><svg class="icon icon-linkedin" enable-background="new 7 -7 30 30" height="16px" viewbox="7 -7 30 30" width="16px"><g><path class="icon-li-background" d="M10-7h24c1.7,0,3,1.3,3,3v24c0,1.7-1.3,3-3,3H10
c-1.7,0-3-1.3-3-3V-4C7-5.7,8.3-7,10-7z" fill="#0084BF"></path><path class="icon-li-text" d="M31,14.6h-3.8V9.1c0-1.4-0.6-2.4-1.9-2.4c-1,0-1.5,0.7-1.8,1.3
c-0.1,0.2-0.1,0.5-0.1,0.9v5.7h-3.7c0,0,0-9.7,0-10.6h3.7v1.7c0.2-0.7,1.4-1.8,3.3-1.8c2.4,0,4.2,1.5,4.2,4.8V14.6L31,14.6z
M16,2.7L16,2.7c-1.2,0-2-0.8-2-1.8c0-1,0.8-1.8,2-1.8c1.2,0,2,0.8,2,1.8C18,1.9,17.2,2.7,16,2.7L16,2.7z M14.4,4h3.3v10.6h-3.3V4z
" fill="#FFFFFF"></path></g></svg><span class="awli-button-label">Apply with Linkedin</span></div><div class="completed"><svg class="icon icon-check" height="16px" viewbox="0 0 16 16" width="16px"><path d="M6.2,14.4L0,8.2l2.5-2.5l3.5,3.5c0.1,0.1,0.2,0.1,0.2,0L13.5,2L16,4.5L6.2,14.4z"></path></svg><span class="awli-button-label">Profile added</span></div></button>
Input 2:
  Label: Resume/CV *
  Type: file
  Values: []
  Is Hidden: False
  HTML: <input class="application-file-input invisible-resume-upload" data-qa="input-resume" id="resume-upload-input" name="resume" tabindex="-1" type="file"/>
Input 3:
  Label: Full name
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input name="name" required="" type="text"/>
Input 4:
  Label: Email
  Type: email
  Values: []
  Is Hidden: False
  HTML: <input name="email" pattern="[a-zA-Z0-9.#$%&amp;'*+\/=?^_`{|}~][a-zA-Z0-9.!#$%&amp;'*+\/=?^_`{|}~-]*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*" required="" type="email"/>
Input 5:
  Label: Phone ✱
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input name="phone" required="" type="text"/>
Input 6:
  Label: Current company ✱
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input name="org" required="" type="text"/>
Input 7:
  Label: LinkedIn URL
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input name="urls[LinkedIn]" type="text"/>
Input 8:
  Label: GitHub URL
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input name="urls[GitHub]" type="text"/>
Input 9:
  Label: To be considered, you must not require Visa Sponsorship now or in the future. Please confirm your status: *
  Type: select
  Values: ['Select...', 'U.S. Citizen', 'Lawful Permanent Resident / Green Card Holder', 'H1B/ Visa / None of the Above']
  Is Hidden: False
  HTML: <select name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field0]"><option value="">Select...</option><option>U.S. Citizen</option><option>Lawful Permanent Resident / Green Card Holder</option><option>H1B/ Visa / None of the Above</option></select>
Input 10:
  Label: Do you currently have a security clearance or the ability to obtain one? *
  Type: select
  Values: ['Select...', 'Currently have clearance', 'Clearance currently in process', 'Does not have a clearance, but eligible and open to obtaining one', 'Does not have a clearance and not interested in obtaining one']
  Is Hidden: False
  HTML: <select name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field1]"><option value="">Select...</option><option>Currently have clearance</option><option>Clearance currently in process</option><option>Does not have a clearance, but eligible and open to obtaining one</option><option>Does not have a clearance and not interested in obtaining one</option></select>
Input 11:
  Label: Are you fully Vaccinated from Covid-19?
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="card-field-input" name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field2]"></textarea>
Input 12:
  Label: What is your desired pay for this role? *
  Type: text
  Values: []
  Is Hidden: False
  HTML: <input class="card-field-input" name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field3]" placeholder="Type your response" required="required" type="text" value=""/>
Input 13:
  Label: When would you be available to start? *
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="card-field-input" name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field4]" required="required"></textarea>
Input 14:
  Label: Have you applied for another role with Govini within the last 6 months? *
  Type: select
  Values: ['Select...', 'Yes', 'No']
  Is Hidden: False
  HTML: <select name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field5]"><option value="">Select...</option><option>Yes</option><option>No</option></select>
Input 15:
  Label: If so, please include role title:
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="card-field-input" name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field6]"></textarea>
Input 16:
  Label: Are you fully vaccinated from COVID-19?
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="card-field-input" name="cards[0d3f1846-4ea3-4cbf-b1eb-aed98ba4c2c1][field0]"></textarea>
Input 17:
  Label: Placeholder ~ Add a cover letter or anything else you want to share
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea id="additional-information" name="comments" placeholder="Add a cover letter or anything else you want to share."></textarea>
Input 18:
  Label: Gender
  Type: select
  Values: ['Select ...', 'Male', 'Female', 'Decline to self-identify']
  Is Hidden: False
  HTML: <select name="eeo[gender]"><option value="">Select ...</option><option value="Male">Male</option><option value="Female">Female</option><option value="Decline to self-identify">Decline to self-identify</option></select>
Input 19:
  Label: Race
  Type: radio
  Values: ['Hispanic or Latino', 'White (Not Hispanic or Latino)', 'Black or African American (Not Hispanic or Latino)', 'Native Hawaiian or Other Pacific Islander (Not Hispanic or Latino)', 'Asian (Not Hispanic or Latino)', 'American Indian or Alaska Native (Not Hispanic or Latino)', 'Two or More Races (Not Hispanic or Latino)', 'Decline to self-identify']
  Is Hidden: False
  HTML: <input name="eeo[race]" type="radio" value="Hispanic or Latino"/><input name="eeo[race]" type="radio" value="White (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Black or African American (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Native Hawaiian or Other Pacific Islander (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Asian (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="American Indian or Alaska Native (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Two or More Races (Not Hispanic or Latino)"/><input name="eeo[race]" type="radio" value="Decline to self-identify"/>
Input 20:
  Label: Veteran status
  Type: select
  Values: ['Select ...', 'I identify as one or more of the classifications of protected veteran listed above', 'I am not a protected veteran', 'I decline to self-identify for protected veteran status']
  Is Hidden: False
  HTML: <select name="eeo[veteran]"><option value="">Select ...</option><option value="I am a Protected Veteran">I identify as one or more of the classifications of protected veteran listed above</option><option value="I am not a Protected Veteran">I am not a protected veteran</option><option value="Decline to self-identify">I decline to self-identify for protected veteran status</option></select>
Input 21:
  Label: Disability status
  Type: select
  Values: ['Select ...', 'Yes, I have a disability, or have a history/record of having a disability', "No, I don't have a disability, or a history/record of having a disability", "I don't wish to answer"]
  Is Hidden: False
  HTML: <select id="disabilitySelectElement" name="eeo[disability]"><option value="">Select ...</option><option value="Yes, I have a disability, or have a history/record of having a disability">Yes, I have a disability, or have a history/record of having a disability</option><option value="No, I don't have a disability, or a history/record of having a disability">No, I don't have a disability, or a history/record of having a disability</option><option value="I don't wish to answer">I don't wish to answer</option></select>

Input 24:
  Label: 
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button class="hidden" id="hcaptchaSubmitBtn" type="submit"></button>
Input 25:
  Label: 
  Type: button
  Values: []
  Is Hidden: False
  HTML: <button class="postings-btn template-btn-submit golden-poppy" data-qa="btn-submit" href="#" id="btn-submit" type="button">Submit application</button>


For Input 17 and 12 I think you what I meant backwards because this is the response I'm looking for











def get_form_input_details(url):
    ...
    for i, field in enumerate(form_fields, start=1):
        ...
        if field.name == 'button':
            input_type = 'button'
            # Skip the hidden reCAPTCHA button
            if field.get('id') == 'hcaptchaSubmitBtn':
                continue
        ...




















Ok the return from the terminal didn't really include any label key values. How would I change the method to make it reflect all the below label key values?
Input 1:
  Label: LinkedIn profile
Input 2:
  Label: Resume/CV *
Input 3:
  Label: Full name *
Input 4:
  Label: Email *
Input 5:
  Label: Phone ✱
Input 6:
  Label: Current company ✱
Input 7:
  Label: LinkedIn URL
Input 8:
  Label: GitHub URL
Input 9:
  Label: To be considered, you must not require Visa Sponsorship now or in the future. Please confirm your status: *
Input 10:
  Label: Do you currently have a security clearance or the ability to obtain one? *
Input 11:
  Label: Are you fully Vaccinated from Covid-19?
Input 12:
  Label: What is your desired pay for this role? *
Input 13:
  Label: When would you be available to start? *
Input 14:
  Label: Have you applied for another role with Govini within the last 6 months? *
Input 15:
  Label: If so, please include role title:
Input 16:
  Label: Are you fully vaccinated from COVID-19?
Input 17:
  Label: Placeholder ~ Add a cover letter or anything else you want to share
Input 18:
  Label: Gender
Input 19:
  Label: Race
Input 20:
  Label: Veteran status
Input 21:
  Label: Disability status
Also remember that this has to work for all different kinds of forms so keeping the code general is better as that can be used universally for all forms!









































So I have these values in a .env file
UNTOUCHED_USER='False'
LAST_APPLIED=''
LINKEDIN_USERNAME=''
LINKEDIN_PASSWORD=''
HOME_RESUME_PATH='C:\Users\user\OneDrive\Desktop\Resume_23.pdf'
WORK_RESUME_PATH='/Users/nliebmann/Downloads/Resume_23.pdf'
FIRST_NAME='Dr. Oliver'
MIDDLE_INITIAL=''
LAST_NAME='Clothesoff'
EMAIL=''
PHONE_NUMBER='6669116969'
HOME_PHONE=''
LOCATION_CITY=''
ZIP_CODE=''
SCHOOL='University of Missouri'
DEGREE='B.S.'
DISCIPLINE='Gynecology'
SCHOOL_START_DATE_MONTH='08'
SCHOOL_START_DATE_YEAR='1969'
SCHOOL_END_DATE_MONTH='05'
SCHOOL_END_DATE_YEAR='1970'
GPA='12.0'
CURRENT_COMPANY='Koles Kaligraphy Kinc'
CURRENT_TITLE='Prevert'
COMPANY_START_DATE='01/02/2020'
CURRENT_EMPLOYEE='False'
COMPANY_END_DATE=''
LINKEDIN_URL=''
GITHUB_URL=''
PERSONAL_URL=''
US_CITIZEN='True'
GENDER='Male'
PRONOUNS=''
SEXUAL_ORIENTATION='Yes please'
RACE='GO'
and a dictionary variable with this key value setup
form_input_details.append({
                'label': input_label,
                'type': input_type,
                'values': values,
                'is_hidden': is_hidden,
                'html': input_html,
                'dynamic': is_dynamic,
                'related_elements': related_elements,
            })
so I need to write a method that fills in a form field. In my form_input_details this is what every key value represents
                'label'=the string from the form that tells us what needs to be inserted into a specific form field
                'type'=the way we will input our info(Ex. dropdown selection, radio buttons, textarea, etc.)
                'values'=If the input only allows for a select list of responses then their listed here(Ex. For Gender values would be [Male, Female, Other])
                'is_hidden'=whether the element where we will have Selenium insert our values is hidden or not
                'html'=the element where we insert our information(that way Selenium can quickly insert our values)
now the method should use the label key to find its corresponding value from the .env file which I read and inserted into my program like this.
        env_path = "../.env"
        load_dotenv(dotenv_path=env_path)
        self.users_information = {k: v for k, v in os.environ.items()}
        print(self.users_information)
also here are some example form_input_details values  from this website [https://boards.greenhouse.io/doubleverify/jobs/6622484002]
Input 13:
  Label: When would you be available to start? *
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="card-field-input" name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field4]" required="required"></textarea>
Input 14:
  Label: Have you applied for another role with Govini within the last 6 months? *
  Type: select
  Values: ['Select...', 'Yes', 'No']
  Is Hidden: False
  HTML: <select name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field5]"><option value="">Select...</option><option>Yes</option><option>No</option></select>
Input 15:
  Label: If so, please include role title:
  Type: textarea
  Values: []
  Is Hidden: False
  HTML: <textarea class="card-field-input" name="cards[9756f0c0-a0e2-4757-b029-85f781432dba][field6]"></textarea>












































can you think of a better more clever way to write it? If you look at this website [https://jobs.lever.co/clubhouse/e1faf52e-a35f-41f2-b2e5-250d5f1777be/apply] it asks for a full name instead of First and Last name which means from the .env file we'd have to do something like
full_name = FIRST_NAME + ' ' + MIDDLE_INITIAL + ' ' + LAST_NAME. So in special cases like that what do you suggest I do? Also I didn't know how but if we come across a completely new question(label) that isn't in the .env can you stop the program and show user the question, and answers if available, to have them answer it and save their response into a variable so we can insert it into the .env later. 


can you think of a better more clever way to write it? If you look at this website [https://jobs.lever.co/clubhouse/e1faf52e-a35f-41f2-b2e5-250d5f1777be/apply] it asks for a full name instead of First and Last name which means from the .env file we'd have to do something like
full_name = FIRST_NAME + ' ' + MIDDLE_INITIAL + ' ' + LAST_NAME. So in special cases like that what do you suggest I do? Also I didn't know how but if we come across a completely new question(label) that isn't in the .env can you stop the program and show user the question, and answers if available, to have them answer it and save their response into a variable so we can insert it into the .env later. Also can you finish writing the method I'll provide my method that creates my form_input_details in case it helps
    def get_form_input_details(self, url):
        page = requests.get(url)
        soup = BeautifulSoup(page.content, 'html.parser')

        form_fields = soup.find_all(['input', 'textarea', 'button', 'select'])

        form_input_details = []
        processed_radios = set()

        for i, field in enumerate(form_fields, start=1):
            input_type = field.get('type')
            input_id = field.get('id')
            input_label = ''
            is_hidden = field.get('style') == 'display: none;' or input_type == 'hidden'
            input_html = str(field).strip()

            if field.name == 'button':
                input_type = 'button'
                # Skip captcha buttons
                if 'h-captcha' in field.get('class', []) or 'g-recaptcha' in field.get('class', []):
                    continue
            elif field.name == 'textarea':
                input_type = 'textarea'
            elif field.name == 'select':
                input_type = 'select'

            # Add a check for the input types you want to keep
            if input_type not in ['text', 'email', 'password', 'select', 'radio', 'checkbox', 'textarea', 'button'] and input_id != 'education_school_name':
                continue

            values = []
            if input_type == 'select':
                options = field.find_all('option')
                for option in options:
                    values.append(option.text.strip())

            if input_type == 'radio':
                #print("Radio button in get_form_input_details:", field)  # Debugging line
                radio_name = field.get('name')
                if radio_name in processed_radios:
                    continue
                processed_radios.add(radio_name)
                radio_group = soup.find_all('input', {'name': radio_name})
                values = [radio.get('value') for radio in radio_group]
                input_html = ''.join([str(radio).strip() for radio in radio_group])
                
                #radio_button = soup.find('input', attrs={'name': 'eeo[race]', 'type': 'radio'})
                #self.print_parent_hierarchy(radio_button)
                
                # Call get_label for the entire radio button group
                input_label = self.get_labia(field)
            else:
                # Call get_label for other input types
                input_label = self.get_labia(field)

            # Skip hidden fields without a label
            if is_hidden and not input_label:
                continue

            is_dynamic = False
            related_elements = []

            # Check the field's ancestors for the 'data-show-if' attribute and 'display: none;' style
            current_element = field
            while current_element:
                if current_element.has_attr('data-show-if'):
                    is_dynamic = True
                    related_elements = [
                        {
                            'related_field_id': current_element['data-show-if'].split('==')[0],
                            'trigger_value': current_element['data-show-if'].split('==')[1],
                        }
                    ]
                if current_element.get('style', '') == 'display: none;':
                    is_hidden = True
                current_element = current_element.find_parent()

            form_input_details.append({
                'label': input_label,
                'type': input_type,
                'values': values,
                'is_hidden': is_hidden,
                'html': input_html,
                'dynamic': is_dynamic,
                'related_elements': related_elements,
            })

        return form_input_details











































So my method
    def search_results(self, list_first_index, list_last_index):
        # Wait for the last result from the previous search to appear on the page
        # if self.results_from_search:
        #     last_result = self.results_from_search[-1]
        #     WebDriverWait(self.browser, 10).until(
        #         EC.visibility_of(last_result)
        #     )
        
        if list_first_index == 0:
            self.results_from_search = self.browser.find_elements(By.CSS_SELECTOR, f"div.g:nth-child(n+{list_first_index})")
            list_last_index = len(self.results_from_search)
        else:
            self.results_from_search = self.browser.find_elements(By.CSS_SELECTOR, f"div.g:nth-child(n+{list_first_index+1})")
            list_last_index = list_first_index + len(self.results_from_search)
        print("\nI am in search_results() below if-else...")
        print("results_from_search = ", end="")
        print(self.results_from_search)
        print("\nI am in search_results() below if-else...")
        print("First Index = " + str(list_first_index) + " && Last Index = " + str(list_last_index))
        for count, results_link in enumerate(self.results_from_search, list_first_index):
            print('--------------------------------')
            print(str(count+1) + "/" + str(list_last_index))
            # Process and print results_link here
            print(results_link)
            link = results_link.find_element(By.CSS_SELECTOR, "a")  #"h3.LC201b > a"
            print(f"Here is link #{count+1}: ", end="")
            job_link = link.get_attribute("href")
            print(job_link)
            
            if count == list_last_index:
                list_first_index = list_last_index
                break
        print("\nI am at end of search_results()...")
        print("First Index = " + str(list_first_index) + " && Last Index = " + str(list_last_index))
        return list_last_index
here, in the for loop prints all the previous results but I want it to only print out the ones it added to self.results_from_search during this call. The purpose of this line of code
print(str(count+1) + "/" + str(list_last_index))
is that str(list_last_index) tells me how many results have been found till now and then str(count+1) tells me which specific indices were added during this call. Is there a clever way we can keep the code the same and make list_first_index in the for loop equal to the length of self.results_from_search when we first started the method that way the for loop enumerates up to the current length?













































def get_jobs_users_applied_to(self):
    job_data_absolute_path = r'../Scraper/JobData.csv'
    previously_applied_to_job_links = []

    with open(job_data_absolute_path, 'r') as file:
        csv_reader = csv.reader(file)
        
        # Skip the header row
        next(csv_reader)

        for row in csv_reader:
            row_without_last_column = row[:-1]
            updated_row = [cell.replace('=>', ',') for cell in row_without_last_column]
            print(updated_row)
            previously_applied_to_job_links.append(updated_row)
    print("These are all the links you already applied to... Tom")
    print(previously_applied_to_job_links)
    self.filter_out_jobs_user_previously_applied_to(previously_applied_to_job_links)  # Pass the list as an argument

def filter_out_jobs_user_previously_applied_to(self, previously_applied_to_job_links):
    new_search_results = []  # Use a new list to store filtered results

    for google_search_result_URL in self.google_search_results_links:
        found = False
        for previously_applied_URL in previously_applied_to_job_links:
            if google_search_result_URL == previously_applied_URL:
                print("Match google_search_result_URL: ", end='')
                print(google_search_result_URL)
                print("Match previously_applied_URL: ", end='')
                print(previously_applied_URL)
                found = True
                break
        if not found:
            new_search_results.append(google_search_result_URL)

    print("These are all the links you already applied to... ")
    print(previously_applied_to_job_links)
    self.google_search_results_links = new_search_results  # Update the original list with filtered results
    return



















































    def determine_current_page(self, job_link, application_company_name):
        soup = self.apply_beautifulsoup(job_link, "lxml")
        
        if application_company_name == "lever":
            webpage_body = soup.find('body')

            opening_link_application = soup.find('div', {"class": 'application-page'})
            opening_link_description = soup.find('div', {"class": 'posting-page'})
            opening_link_company_jobs = soup.find('div', {"class": "list-page"})

            #opening_link_application = soup.find('div', {"class": 'application-page'})
            if opening_link_application:
                try:
                    self.lever_co_header(webpage_body, soup)

                    try:
                        self.company_open_positions_a.click()
                    except:
                        raw_link = company_open_positions['href']
                        self.browser.get(raw_link)
                    time.sleep(2)
                    return
                except:
                    #TODO: Change this Error type!
                    raise ConnectionError("ERROR: Companies other open positions are not present")
                
            elif opening_link_description:
                #try:
                apply_button = None
                
                a_tag_butt = soup.find('a', {'data-qa': 'btn-apply-bottom'})
                div_tag_butt = soup.find('div', {'data-qa': 'btn-apply-bottom'})
                application_at_bottom = soup.find("div", id="application")
                print("Application at bottom or <button>")
                if a_tag_butt:
                    #print("== Application at bottom of page")
                    print("\tPress button to go to application")
                    apply_button = a_tag_butt
                    apply_to_job = self.should_user_apply(opening_link_description)
                elif div_tag_butt:
                    print("\tPress button to go to application")
                    apply_button = div_tag_butt
                    apply_to_job = self.should_user_apply(opening_link_description)    #apply_to_job = boolean | T=.click() && F=.lever_header() -> .company_job_openings()
                if apply_to_job == True:
                    print("1st lever application locked and loaded")
                    apply_button.click()
                    time.sleep(5)
                    current_url = self.browser.current_url
                    soup = self.apply_beautifulsoup(current_url, "html")
                    form_input_details = self.get_form_input_details(current_url)
                    self.insert_resume()
                    self.fill_out_application(form_input_details)
                    self.keep_jobs_applied_to_info()
                    #TODO: If the button is present click OTHERWISE just insert the link
                    if self.company_other_openings_href:
                        self.company_other_openings_href.click()
                    else:
                        self.browser.get(self.company_other_openings_href)
                    return
                elif not apply_to_job:
                    #TODO:
                    self.company_other_openings_href.click()
                    return
                # except:
                #     raise ("Something went wrong with the the greenhouse.io job_description page")
            elif opening_link_company_jobs:
                #TODO: parse through other_company_jobs for "lever"
                #self.company_job_openings(soup, None, application_company_name)
                return
            application = opening_link_application
        













        elif application_company_name == "greenhouse":
            div_main = soup.find("div", id="main")
            job_description_element = self.browser.find_element(By.ID, "content")
            
            #I did it this way because it checks very few elements since 1 of these options are normally literally the next element
            next_elem = div_main.find_next()
            while next_elem:    #NOTE: REMEBER THIS DOESN'T INCREMENT next_elem SO IT'S THE SAME VALUE AS ABOVE!!!!
                if next_elem.name == "div" and (next_elem.get("id") == "flash-wrapper" or next_elem.get("id") == "flash_wrapper"):
                    print('-Job Listings Page')
                    return
                elif (next_elem.name == "div" and next_elem.get("id") == "embedded_job_board_wrapper"):
                    print('-Job Listings Page')
                    return
                elif (next_elem.name == "section" and next_elem.get("class") == "level-0"):
                    print("-Company Job Openings Page")
                    print("A while loop for this is perfect for this because there can be multiple <section class='level-0'>")
                    #TODO: for this one in the elif you have to look through all "level-0" sections!!
                    return
                elif next_elem.name == "div" and next_elem.get("id") in ["app-body", "app_body"]:
                    app_body = next_elem
                    header = next_elem.find("div", id="header")
                    content = next_elem.find("div", id="content")
                    
                    if header and content:
                        print("Job Description Page")
                        #TODO: Fix this!!! I need the header link!
                        self.greenhouse_io_header(app_body, header, content)    #TODO: return *job_title, company, location, ???*
                        should_apply = self.should_user_apply()
                        if should_apply == True:
                            #This should setup the code so that it's lookin down the barrell of the application! Everything should already be setup!!!
                            self.bottom_has_application_or_button()
                        elif should_apply == False:
                            try:
                                self.company_other_openings_href.click()
                            except:
                                self.browser.get(self.company_other_openings_href)
                            time.sleep(2)
                            return
                            
                        #TODO
 #! ^ MOVE UP 198 ^ ^ ^ ^ ^ ^ ^                       apply_button = div_main.find("button", text=["Apply Here", "Apply Now"])  #NOTE: !!!!! Maybe greenhouse doesn't have <button> ...    maybe it only has <a class="button">!?!?!?
                        #application_below_description = div_main.find("div", id="application")
                        #NOTE: I don't think greenhouse.io house <... target="_blank">
                        #if apply_button:
                            #print("\tPress button to go to application")
                            #should_apply = self.should_user_apply()
                            #print("\t\tApply button: ", end="")
                            #print(apply_button)
                            #if should_apply == True:
                                #apply_button.click()
                                #time.sleep(5)
                                #self.greenhouse_io_application(application)
                            #print("\t\tApplication = ", end="")
                            #print(application)
                            #apply_to_job = self.should_user_apply(application)
                            #return application
                        #elif application:
                            #self.should_user_apply(application)
                            #print("\tApplication at bottom of page")
                            
                        else:
                            print("\tHmmm that's weird ? it's neither button nor application")
                        
                        # self.scroll_to_element(job_description_element)
                        # if apply_to_job == True:
                        print("1st greenhouse application locked and loaded")
                        form_input_details = self.get_form_input_details(job_link)
                        print("Meet")
                        time.sleep(8)
                        self.insert_resume()
                        print("me")
                        time.sleep(8)
                        self.fill_out_application(form_input_details)
                        self.keep_jobs_applied_to_info(job_link)
                        # elif apply_to_job == False:
                        #     self.a_href.click()
                        #     time.sleep(4)
                        #     return
                    break
                else:
                    next_elem = next_elem.find_next()
            print("Not really sure how the heck we got here and defintiely don't have a clue about where to go from here!?!?!?")
            return












































<input aria-required="false" id="job_application_answers_attributes_4_answer_selected_options_attributes_0_question_option_id" name="job_application[answers_attributes][4][answer_selected_options_attributes][0][question_option_id]" set="23367632002" type="checkbox" value="110843031002"/>













































<selenium.webdriver.remote.webelement.WebElement (session="4f1effbf-5809-47b1-a222-454e9ce4e82b", element="5b41eb0a-4462-484f-93b6-72b73aeb9768")>
<selenium.webdriver.remote.webelement.WebElement (session="4f1effbf-5809-47b1-a222-454e9ce4e82b", element="5b41eb0a-4462-484f-93b6-72b73aeb9768")>













































<label>
  <input type="checkbox" name="job_application[answers_attributes][11][answer_selected_options_attributes][0][question_option_id]" id="job_application_answers_attributes_11_answer_selected_options_attributes_0_question_option_id" value="129947029" set="39705180" aria-required="false">
    &nbsp;&nbsp;Alaskan Native / American Indian / Indigenous American / Native American
</label>


This is a checkbox input
<label>
  <input type="checkbox" name="job_application[answers_attributes][11][answer_selected_options_attributes][0][question_option_id]" id="job_application_answers_attributes_11_answer_selected_options_attributes_0_question_option_id" value="129947029" set="39705180" aria-required="false">
    &nbsp;&nbsp;Alaskan Native / American Indian / Indigenous American / Native American
</label>
and it has many more options but I'm just using this one as an example, since they are all pretty much the same. Now, the label to this checkbox along with its siblings is the string 'I identify my ethnicity as (mark all that apply)'. So as the user I can see that I am allowed to click as many of these checkboxes as I want 















































So I'm working on a python project that fills out forms for users. So I save the user's information in their .env file which is organized like this
UNTOUCHED_USER='False'
USERS_BROWSER_CHOICE=''
LINKEDIN_USERNAME='Liebmann.nicholas1@gmail.com'
LINKEDIN_PASSWORD='nockers'
THE_INTERNET_USERNAME='admin'
THE_INTERNET_PASSWORD='admin'
RESUME_PATH='C:\Users\user\OneDrive\Desktop\Nicholas_Liebmann_Resume_23.pdf'
FIRST_NAME='Nicholas'
MIDDLE_INITIAL='J.'
LAST_NAME='Liebmann'
EMAIL='Liebmann.nicholas1@gmail.com'
PHONE_NUMBER='6614787829'
HOME_PHONE=''
USERS_CITY='Austin'
USERS_STATE='Texas'
USERS_ZIP_CODE='78741'
SCHOOL='San Jose State University'
DEGREE='B.S.'
DISCIPLINE='Mathematics'
SCHOOL_START_DATE_MONTH='08'
SCHOOL_START_DATE_YEAR='2015'
SCHOOL_END_DATE_MONTH='05'
SCHOOL_END_DATE_YEAR='2020'
GPA='2.9'
CURRENT_COMPANY='Apex Systems'
CURRENT_TITLE='Data Analyst'
now there's more info in the .env file and these are just examples of the first few. So basically my code uses Selenium and BeautifulSoup4 to organize the form input fields into a dictionary variable named form_input_details which consists of values that look like this 
Input 17:
  Label: How would you describe your sexual orientation? (mark all that apply)
  Type: checkbox
  Values: ["Asexual", "Bisexual and/or pansexual", "Gay", "Heterosexual", "Lesbian", "Queer", "I prefer to self-describe", "I don't wish to answer"]
  Is Hidden: False
  HTML: 
  Dynamic: False
  Related Elements: []
Input 18:
  Label: Do you identify as transgender? (Select one)
  Type: checkbox
  Values: ["Yes", "No", "I prefer to self-describe", "I don't wish to answer"]
  Is Hidden: False
  HTML: 
  Dynamic: False
  Related Elements: []
so each value value is defined as below
Input 00: -The number in which this input tag appears in the form
  Label: -The string value that informs the user what information is needed for this specific input
  Type: -How my code will insert the users value so Ex. checkbox input, radio input, button, etc.
  Values: -A list of predefined values that the user has to choose from; if any
  Is Hidden: -Determines whether this input field is hidden or not
  HTML: -All the HTML code that contains the Label and Values value so inserting users values are quicker
  Dynamic: -Whether this input field contains anything dynamic
  Related Elements: -If Dynamic's value is True then this is where we store that dynamic code
so as you can see because of my preparation I can easily use the label from my variable form_input_details











































I apologize here is the 1st link again
https://github.com/Liebmann5/Web_Scraper/tree/main/Legit
and here is the 2nd link
https://github.com/Liebmann5/Web_Scraper














ok so those are normally 3 seperate files but I put them in 1 so it's easier to read and sepeated each of them with this #--------------------00----------------------------------------------------------------------------------------------------. Anyways are you able to tell me where I originally defined self.company_job_openings and where I 1st assigned it a value? If possible are you able to tell me what values it is recieving and from where?

























What changes do you think I need to make in my CompanyOpeningsAndApplications.py file? I feel like it's some great code but major changes need to be made. I want this to be an amazing piece of software so what changes would you make and why? Then could you explain how to implement those changes and why they would be crucial changes to make my code great? Finally could you show me what that code would look like?
















































Ok so I need help manipulating a list but am first wondering if I can possibly use my already present methods to do so. I'm wondering if you see an extremely clever way to accomplish what I'm wanting  and I'll put all the coding below here

    def encapsulate_companies_urls(self, list_to_filter):
        print("\nencapsulate_companies_urls()")
        updated_google_search_results_links = []
        completely_filtered_list = []
        seen_urls = set()

        for i, indexed_job in enumerate(list_to_filter):
            parsed_url = urlparse(indexed_job)
            base_url = urlunparse((parsed_url.scheme, parsed_url.netloc, '', '', '', ''))
            company_url = '/'.join(parsed_url.path.strip('/').split('/')[:1])
            company_base_url = urlunparse((parsed_url.scheme, parsed_url.netloc, company_url, '', '', ''))

            if company_base_url not in seen_urls:
                seen_urls.add(company_base_url)
                updated_google_search_results_links.append(indexed_job)

                company_filtered_list = [url for url in list_to_filter if company_base_url in url]
                if len(company_filtered_list) > 1:
                    print("company_filtered_list = ", company_filtered_list)
                    completely_filtered_list.append(company_filtered_list)

        print("\n\n    Sup Captain -------")
        print("updated_google_search_results_links = ", updated_google_search_results_links)
        print("updated_google_search_results_links = ", str(len(updated_google_search_results_links)))
        print("completely_filtered_list = ", completely_filtered_list)
        print("completely_filtered_list = ", str(len(completely_filtered_list)))
        self.print_lists_side_by_side(list_to_filter, updated_google_search_results_links)
        return updated_google_search_results_links, completely_filtered_list
usng that manipulate lists 










































ok can you read my CompanyOpeningsAndApplications.py file in my repo here https://github.com/Liebmann5/Web_Scraper/Legit, please. Then tell what caused these 2 errors and then how to fix them?
(virtual_environments_smell_like_updog) nliebmann@dhcp017104094139 Web_Scraper % python3 Legit/JobSearchWorkflow.py > terminalOutput.txt
Traceback (most recent call last):
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/CompanyOpeningsAndApplications.py", line 235, in determine_current_page
    self.lever_co_banner(webpage_body, soup)
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/CompanyOpeningsAndApplications.py", line 855, in lever_co_banner
    print("Selenium Click => Companies other Job Openings: " + self.company_open_positions_a)
TypeError: can only concatenate str (not "Tag") to str

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/JobSearchWorkflow.py", line 1068, in <module>
    workflow.job_search_workflow()
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/JobSearchWorkflow.py", line 127, in job_search_workflow
    self.apply_to_jobs(last_link_from_google_search, user_desired_jobs, user_preferred_locations, completely_filtered_list)
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/JobSearchWorkflow.py", line 357, in apply_to_jobs
    CompanyWorkflow(self, self.browser, self.users_information, user_desired_jobs, user_preferred_locations, self.sessions_applied_to_info, self.tokenizer, self.model, self.nlp, self.lemmatizer, self.custom_rules, self.q_and_a, self.custom_synonyms, senior_experience=False).company_workflow(job_link)
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/CompanyOpeningsAndApplications.py", line 180, in company_workflow
    self.determine_current_page(job_link, self.application_company_name)
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/CompanyOpeningsAndApplications.py", line 251, in determine_current_page
    raise ConnectionError("ERROR: Companies other open positions are not present")
ConnectionError: ERROR: Companies other open positions are not present
(virtual_environments_smell_like_updog) nliebmann@dhcp017104094139 Web_Scraper % python3 Legit/JobSearchWorkflow.py > terminalOutput.txt
Traceback (most recent call last):
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/JobSearchWorkflow.py", line 1068, in <module>
    workflow.job_search_workflow()
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/JobSearchWorkflow.py", line 110, in job_search_workflow
    self.browser_setup()
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/JobSearchWorkflow.py", line 199, in browser_setup
    self.browser = webdriver.Safari(options=options)
  File "/Users/nliebmann/Library/Python/3.9/lib/python/site-packages/selenium/webdriver/safari/webdriver.py", line 110, in __init__
    super().__init__(command_executor=executor, options=options)
  File "/Users/nliebmann/Library/Python/3.9/lib/python/site-packages/selenium/webdriver/remote/webdriver.py", line 286, in __init__
    self.start_session(capabilities, browser_profile)
  File "/Users/nliebmann/Library/Python/3.9/lib/python/site-packages/selenium/webdriver/remote/webdriver.py", line 378, in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
  File "/Users/nliebmann/Library/Python/3.9/lib/python/site-packages/selenium/webdriver/remote/webdriver.py", line 440, in execute
    self.error_handler.check_response(response)
  File "/Users/nliebmann/Library/Python/3.9/lib/python/site-packages/selenium/webdriver/remote/errorhandler.py", line 245, in check_response
    raise exception_class(message, screen, stacktrace)
selenium.common.exceptions.SessionNotCreatedException: Message: Could not create a session: The Safari instance is already paired with another WebDriver session.

(virtual_environments_smell_like_updog) nliebmann@dhcp017104094139 Web_Scraper % python3 Legit/JobSearchWorkflow.py > terminalOutput.txt
Traceback (most recent call last):
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/JobSearchWorkflow.py", line 1068, in <module>
    workflow.job_search_workflow()
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/JobSearchWorkflow.py", line 127, in job_search_workflow
    self.apply_to_jobs(last_link_from_google_search, user_desired_jobs, user_preferred_locations, completely_filtered_list)
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/JobSearchWorkflow.py", line 357, in apply_to_jobs
    CompanyWorkflow(self, self.browser, self.users_information, user_desired_jobs, user_preferred_locations, self.sessions_applied_to_info, self.tokenizer, self.model, self.nlp, self.lemmatizer, self.custom_rules, self.q_and_a, self.custom_synonyms, senior_experience=False).company_workflow(job_link)
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/CompanyOpeningsAndApplications.py", line 180, in company_workflow
    self.determine_current_page(job_link, self.application_company_name)
  File "/Users/nliebmann/Desktop/GitHub/Web_Scraper/Legit/CompanyOpeningsAndApplications.py", line 290, in determine_current_page
    job_description_element = self.browser.find_element(By.ID, "content")
  File "/Users/nliebmann/Library/Python/3.9/lib/python/site-packages/selenium/webdriver/remote/webdriver.py", line 831, in find_element
    return self.execute(Command.FIND_ELEMENT, {"using": by, "value": value})["value"]
  File "/Users/nliebmann/Library/Python/3.9/lib/python/site-packages/selenium/webdriver/remote/webdriver.py", line 440, in execute
    self.error_handler.check_response(response)
  File "/Users/nliebmann/Library/Python/3.9/lib/python/site-packages/selenium/webdriver/remote/errorhandler.py", line 245, in check_response
    raise exception_class(message, screen, stacktrace)
selenium.common.exceptions.NoSuchElementException: Message: 

(virtual_environments_smell_like_updog) nliebmann@dhcp017104094139 Web_Scraper % 











































    def init_user(self):
        self.user = (
        users_job_search_requirements = {
            "user_desired_job_title": [],
            "user_preferred_locations": [],
            "user_preferred_workplaceType": ["in-office", "hybrid", "remote"],
            "employment_type": [],  #Not really something I'm checking for
            "entry_level": True, 
        },
        users_personal_information = {
          "users_information": []
        })















































    #! NOT RELATED TO ANYTHING !!!!
    #TODO: Might be apart of the check_banner_links || try_adjusting_this_link
    def is_absolute_path(href):
        print("is_absolute_path()")
        parsed_url = urlparse(href)
        print("The href value is: ", end="")
        print(parsed_url)
        return bool(parsed_url.netloc)
    #! NOT RELATED TO ANYTHING !!!!
    
    
    
    
    #Apart of insert_resume() but   BUT the variable it is set = to I don't think is ever used! (Meaning this code is now useless)
    def get_input_tag_elements(self):
        """
        Returns a list of tuples with input element ID, type and visibility status
        """
        input_elements = self.browser.find_elements(By.TAG_NAME, 'input')
        inputs_info = []
        for input_element in input_elements:
            input_id = input_element.get_attribute('id')
            input_type = input_element.get_attribute('type')
            is_hidden = input_element.get_attribute('type') == 'hidden' or not input_element.is_displayed()
            inputs_info.append((input_id, input_type, is_hidden))
        return inputs_info



    

    #! I BELIEVE...  I  BELIEVE && don't know but seems to be the O.G. start_page_decider 's !!!!!!!
        #! These methods could be for the companies job list page!!!! 
    #filter out already applied jobs
    #traverse job webpage
    #?????
    def lever_io_data(self, joby_link, soup):
        self.joby_link = joby_link
        print("===Ball = inside the lever.co")
        #opening_link_application = soup.find('div', class_='page-application')      #application immediate
        opening_link_application = soup.find('div', {"class": 'application-page'})
        #opening_link_description = soup.find('div', class_='page-show')             #regular description start
        opening_link_description = soup.find('div', {"class": 'posting-page'})          #NOTE: In HTML class='one two' needs 2 class calls I think!?!?!?
        print("===Ball = opening_link_application = ", end="")
        #print(opening_link_application)
        print("You are on the Job Application webpage")
        print("===Ball = opening_link_description = ", end="")
        #print(opening_link_description)
        print("You are on the Job Description webpage")
        try:
            other_company_jobs = soup.find('div', {"class": 'page show'})
            company_open_positions = other_company_jobs.find('a', {"class": "main-header-logo"})
            if company_open_positions['href']:
                plethora_of_jobs = company_open_positions['href']
                print(plethora_of_jobs)
        except:
            print("Couldn't find the logo with the lick to plethora_of_jobs")
        
        #if soup.find('a', class_='main-header-logo'):
        if opening_link_application:
            try:
                company_open_positions = soup.find('a', {"class": "main-header-logo"})
                #company_open_positions = soup.find('a', class_=['main-header-logo', 'main-header'])
                plethora_of_jobs = company_open_positions['href']
                print("===Ball = plethora_of_jobs = ", end="")
                print(plethora_of_jobs)
                application_webpage_html = soup.find("div", {"class": "application-page"})
                self.lever_io_application(joby_link, application_webpage_html)
                #return opening_link_application
            except:
                #TODO: Change this Error type!
                raise ConnectionError("ERROR: Companies other open positions are not present")
        elif opening_link_description:
            print("===Ball = lever.co is working")
            try:
                print("===Ball = inside the try lever.co")
                position_title = soup.find('h2')
                job_title = position_title.get_text().split()
                print("===Ball = job_title = ", end="")
                #print(job_title.get_text())
                print(job_title)
                #? .position_title.find() doesn't work b/c the <h2> and <div> are siblings!!
                # job_info = position_title.find('div', {"class": "posting-categories"})
                job_info = soup.find('div', {"class": "posting-categories"})
                job_location = job_info.find('div', {"class": 'location'}).get_text().strip()
                job_department = job_info.find('div', {"class": 'department'}).get_text().strip()
                job_commitment = job_info.find('div', {"class": 'commitment'}).get_text().strip()
                job_style = job_info.find('div', {"class": 'workplaceTypes'}).get_text().strip()
                print("HERE------------------------------------")
                print(job_location)
        
                a_tag_butt = soup.find('a', {'data-qa': 'btn-apply-bottom'})
                div_tag_butt = soup.find('div', {'data-qa': 'btn-apply-bottom'})
                job_apply_butt = None
                link_to_apply = None
                #job_apply_butt = soup.select_one('a.btn-apply-bottom, div.btn-apply-bottom')
                #if job_apply_butt.name == 'div':
                if div_tag_butt:
                    job_apply_butt = job_apply_butt.find('a')
                    link_to_apply = job_apply_butt['href']
                elif a_tag_butt:
                    link_to_apply = a_tag_butt['href']
                
                print("===Ball = link_to_apply = ", end="")
                print(link_to_apply)

            except:
                #TODO: Change this Error type!
                raise ConnectionError("ERROR: Companies other open positions are not present")
        #print("===Ball = leaving the lever.co")
        return soup

    #if id="app_body" and [check which page you are on]
    
    def greenhouse_io_start_page_decide(self, soup): #if (child of main is one of these)
        print("Welcome fair maiden this company has gathered to make decisions based on your skin color... please after you!")
        div_main = soup.find("div", id="main")
        next_elem = div_main.find_next()
        while next_elem:
            if next_elem.name == "div" and next_elem.get("id") == "flash-wrapper":
                print('-Job Page')
                return soup.find("div", id="flash-wrapper")
                break
            elif (next_elem.name == "div" and next_elem.get("id") == "embedded_job_board_wrapper"):
                print('-Job Listings Page')
                return soup.find("div", id="embedded_job_board_wrapper")
                break
            elif (next_elem.name == "section" and next_elem.get("class") == "level-0"):
                print("-Job Listings Page")
                print("A while loop for this is perfect for this because there can be multiple <section class='level-0'>")
                #TODO: for this one in the elif you have to look through all "level-0" sections!!
                return soup.find("section", {"class": "level-0"})
            elif next_elem.name == "div" and next_elem.get("id") in ["app-body", "app_body"]:
                app_body = next_elem
                header = next_elem.find("div", id="header")
                content = next_elem.find("div", id="content")
                application = soup.find("div", id="application")
                if header and content:
                    print("Job Description Page")
                    self.greenhouse_io_banner(app_body, header, content)
                else:
                    print("Application at bottom or <button>")
                    #TODO
                    apply_button = div_main.find("button", text="Apply Here")
                    if application:
                        self.greenhouse_io_application(application)
                    elif apply_button:
                        apply_button.click()
                        time.sleep(5)
                        self.greenhouse_io_application(application)
                        print("Application = ", end="")
                        print(application)
                        return application
                break
            else:
                next_elem = next_elem.find_next()
        print("Guess the .greenhouse_io_start_page_detector() while loop doesn't work")
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



    def find_visible_input(self, selector):
        input_element = self.browser.find_element(By.CSS_SELECTOR, selector)
        is_hidden = input_element.get_attribute('type') == 'hidden' or not input_element.is_displayed()
        if is_hidden:
            self.browser.execute_script("arguments[0].style.display = 'block';", input_element)
            is_hidden = input_element.get_attribute('type') == 'hidden' or not input_element.is_displayed()
        return input_element, not is_hidden

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!       REMEMBER TO COUNT THE NUMBER OF OPEN SENIOR > ROLES AVAILABLE           !
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #! FIND AND ATTACH RESUME 1st B/C AUTOFILL SUCKS
    def insert_resume(self):
        print("\ninsert_resume()")
        #resume_path = self.users_information.get('WORK_RESUME_PATH')
        resume_path = self.users_information.get('RESUME_PATH')
        print(resume_path)
        
        if self.app_comp == 'greenhouse':
            element = self.browser.find_element(By.XPATH, "//button[text()='Attach']")
            #element = self.browser.find_element(By.XPATH, "//button[contains(text, 'ATTACH')]")
            #element = self.browser.find_elements(By.ID, "application")
            print("0.1 = ", end="")
            print(element)
            if not element:
                element = self.browser.find_element(By.CLASS_NAME, "resume")
                print("0.2 = ", end="")
                print(element)
            if not element:
                element = self.browser.find_element(By.XPATH, "//button[text()='Attach']")
                print("0.3 = ", end="")
                print(element)
            if not element:
                print("That's so silly! Can't scroll")
            self.browser.execute_script("arguments[0].scrollIntoView();", element)
            time.sleep(2)
        print("1")
        
        #for *lever.co* I believe
        resume_file_input = self.browser.find_elements(By.XPATH, '//input[data-qa="input-resume"]')
        print("2")
        print(resume_file_input)
        print("2.1 = ", end="")
        if resume_file_input:
            print("3")
            resume_file_input[0].send_keys(resume_path)
            print("4")
        else:
            print("5")
            self.dismiss_random_popups()
                        #self.browser.execute_script("arguments[0].scrollIntoView();", resume_file_input)
            #resume_upload_button = self.browser.find_element(By.CSS_SELECTOR, 'button.visible-resume-upload')
            try:
                resume_upload_button = self.browser.find_element(By.CSS_SELECTOR, 'button[aria-describedby="resume-allowable-file-types"]')
                if not resume_upload_button:
                    try:
                        resume_upload_button = self.browser.find_element(By.XPATH, "//*[@id[contains(@id, 'resume')]]")
                    except:
                        print("Golly no one can do this...")
                        exit()
            except:
                print("This ain't right dog")
                exit()
            #wait = WebDriverWait(self.browser, 10)
            #overlay_close_button = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, 'button.close-overlay')))
            #overlay_close_button.click()
            #resume_upload_button = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, 'button[aria-describedby="resume-allowable-file-types"]')))
            print("--------------------------------------------------------")
            print(resume_upload_button)
            print("--------------------------------------------------------")
            #print()
            print("6")
            if resume_upload_button:
                time.sleep(1)
                print("8")
                input_elements = self.get_input_tag_elements()
                
                #NOTE: [https://dev.to/razgandeanu/how-to-upload-files-with-selenium-3gj3]
                # input_element, is_visible = self.find_visible_input('input[data-qa="input-resume"]')
                input_element, is_visible = self.find_visible_input('input[type="file"]')
                print("Bargain-Mart")
                print((input_element, is_visible))
                
                
                upload_input = self.browser.find_element(By.CSS_SELECTOR, 'input[type="file"]')
                upload_input.send_keys(resume_path)
                print("8.1")
                time.sleep(2)

                print("13")
            else:
                raise Exception('Could not find resume upload element')
        print("14 Holy Hole")
        return
    
    def get_label(self, input_element):
        # Check for the special case: 'button' and 'submit application' in input_element
        input_element_str = str(input_element).lower()
        if 'button' in input_element_str and 'submit application' in input_element_str:
            return 'Submit Application'
        
        if input_element.get('type') == 'radio':
            label = self.find_radio_label(input_element)
            return label
        
        if input_element.get('type') == 'checkbox':
            div_parent, parents_text = self.get_div_parent(input_element)
            if div_parent == 'None' or parents_text == 'None':
                pass
            elif div_parent and parents_text:
                #return div_parent, parents_text
                checkbox_values = [div_parent, parents_text]
                return checkbox_values

        label = None

        # Case 1: Check if the label is a direct previous sibling of the input element
        label = input_element.find_previous_sibling('label')

        # Case 2: Check if the label is inside a parent container
        if not label:
            parent = input_element.find_parent()
            if parent:
                label = parent.find('label')

        # Case 3: Check if the label is associated using the "for" attribute
        if not label:
            input_id = input_element.get('id')
            if input_id:
                label = input_element.find_previous('label', attrs={'for': input_id})

        # Case 4: Check if the input element is a child of a label element
        if not label:
            parent_label = input_element.find_parent('label')
            if parent_label:
                label = parent_label

        # Case 5: Check if a label is inside a parent container of the input element
        if not label:
            parent = input_element.find_parent()
            if parent:
                label = parent.find('label')
                
        # Case 6: Checks if the input element has an 'aria-label' meaning it's dynamic so goes & searches
        # all previous label containers to see if any have text values that are equal to the aria-label' 
        if not label:
            if 'aria-label' in input_element.attrs:
                aria_label_match = None
                parent_label = input_element.find_previous('label')
                aria_label_value = input_element["aria-label"]
                if parent_label.text.strip() == aria_label_value:
                    aria_label_match = True
                if aria_label_match:
                    dynamic_label = aria_label_value + " (dynamic " + input_element.get('type') + ")"
                    if dynamic_label:
                        return dynamic_label
                elif aria_label_match == None:
                    return aria_label_value
                        
        # Case 7: Checks if the input element's style attribute is equal to 'display: none;' meaning it's
        # dynamic so goes & searches for the most previous label container to specify its text value is dynamic
        if not label:
            if input_element.get('style') == 'display: none;':
                previous_input = input_element.find_previous('input')
                if previous_input:
                    parent_label = previous_input.find_previous('label')
                    dynamic_label = parent_label.text.strip() + " (dynamic " + input_element.get('type') + ")"
                    if dynamic_label:
                        return dynamic_label
                    
        # Case 8: Special case for Resume/CV
        if not label and self.one_resume_label == False:
            found_attach = False
            parent_label = input_element.find_previous('label')
            #print(f"----parent_label ========>>>>> {parent_label}")
            label = parent_label
            self.one_resume_label = True
            #TODO: This whole thing is pee pee poo poo
            current_element = input_element
            while current_element:
                if isinstance(current_element, NavigableString) and 'attach' in str(current_element).lower():
                    found_attach = True
                    break
                current_element = current_element.next_sibling
            # Traverse up from the specific_element and find the label tag
            if found_attach:
                label_tag = input_element.find_previous('label')
                if label_tag:
                    # Check if the immediate child is a text value
                    first_child = label_tag.contents[0]
                    if isinstance(first_child, NavigableString) and first_child.strip():
                        holey_holes = first_child.strip()
                    else:
                        # Check if it has a child element and if it does, save that child's text value
                        for child in label_tag.children:
                            if not isinstance(child, NavigableString):
                                holey_holes = child.get_text(strip=True)
                                break
                    #print(f"Text value of the label: {holey_holes}")
                    label = holey_holes
            else:
                print("No sibling found with the 'attach' keyword.")
                #print("Just to remember input_element = ")
                #print(input_element)

        # Check if the label contains a nested div element with the class "application-label" (case for Input 18)
        if label:
            app_label = label.find(lambda tag: 'class' in tag.attrs and 'application-label' in tag['class'])
            if app_label:
                label = app_label

        if label:
            label_text = label.text.strip()

            # If the standard asterisk (*) or fullwidth asterisk (✱) is present, remove everything after it
            if '*' in label_text:
                label_text = label_text.split('*')[0].strip() + ' *'
            elif '✱' in label_text:
                label_text = label_text.split('✱')[0].strip() + ' ✱'
            else:
                # If the newline character (\n) is present, remove it and everything after it
                label_text = label_text.split('\n')[0].strip()

            return label_text

        # Case 6: Check if the input_element has a placeholder attribute
        placeholder = input_element.get('placeholder')
        if placeholder:
            return f"Placeholder ~ {placeholder}"

        return None
    
    #OG: print_form_heirarchy()
    def find_radio_label(self, element, stop_level=5):
        current_level = 0
        while (current_level <= stop_level):
            print(f"Level {current_level}:")
            if current_level == 0 or current_level == 5:
                if current_level == 0:
                    print(element.prettify())
                if current_level == 5:
                    sauce = element.next_element.get_text(strip=True)
                    #print(sauce)
                    print(sauce)
                    return sauce
            element = element.parent
            current_level += 1



















































thank you for all that but I'm gonna work through each line using bash. I only need you to do 3 things
1. Clean up my code so all the syntax looks good and the comments are gone!
2. Based off my refactoring if you see I missed something; such as didn't include it to the soup_elements or maybe added something incorrectly then please fix my mistakes
3. If you see I was currently working on a piece of my refactoring and didnt finish it then if possible could you please finish it for me and if not or you dont know then it's ok to just leave my code the way it was
Lastly just so you know I reset soup_elements everytime I switch a page which for lever is each index of self.job_application_webpage = ["Internal-Job-Listings", "Job-Description", "Job-Application", "Submitted-Application"] EXCEPT for greenhouse remember! For greenhouse "Job-Description" and "Job-Application" are the same page! Now based off all that and from now on can you write the correct code?


















































    #TODO: This goes to all the links!!
    '''
    def troubleshoot_xpath(self):
        for link in self.list_of_links:
            try:
                self.browser.get(link)
                time.sleep(2)
                job_title = self.browser.title
                print(f"Scraping job: {job_title}")

                # Search for the Google search name in the page
                google_search_name = job_title.split("-")[0].strip()
                print(f"Searching for: {google_search_name}")
                selenium_google_link = self.browser.find_element(By.XPATH, f'//ancestor::a/h3[not(descendant::br)][text()="{google_search_name}"]')
                print("Found search result")

                # Click on the Google search result link
                selenium_google_link.click()
                print("Clicked on the search result link")

                # Wait for the page to load and switch to the new tab
                WebDriverWait(self.browser, 10).until(EC.number_of_windows_to_be(2))
                self.browser.switch_to.window(self.browser.window_handles[-1])
                print("Switched to new tab")

                # Perform actions on the job page
                self.scrape_job_page()

                # Close the new tab and switch back to the search results tab
                self.browser.close()
                self.browser.switch_to.window(self.browser.window_handles[0])
                print("Closed new tab and switched back to search results tab")

            except NoSuchElementException:
                print(f"No search result found for: {google_search_name}")
                continue
    '''



    # STAGE 1: Figure out where ever the heck we are; if we happen to be in a position to fill out a job application then great do that, then get to company_job_openings (Use the header methods to accomplish this!!)  
    # STAGE 2: Once at the Company's Job Listings page -> GO THROUGH ALL THE JOBS   ALL WHILE  1)collecting all the jobs for the user AND 2) collect data for Google Sheets (filterings should take place) return back to CompanyWorkflow
    # STAGE 3: 
    # STAGE :
    # STAGE :
    # STAGE :
    # STAGE :
    





'''
        if opening_link_application:
            print('-Application Page')
            self.soup_elements.update({
                'soup': soup,
                'webpage_body': webpage_body,
                'opening_link_application': opening_link_application
            })
            return self.job_application_webpage[1]
        
        elif opening_link_description:
            print("-Job Description Page")
            self.soup_elements.update({
                'soup': soup,
                'webpage_body': webpage_body,
                'opening_link_description': opening_link_description
            })
            return self.job_application_webpage[0]

        elif opening_link_company_jobs:
            print('-Job Listings Page')
            self.soup_elements.update({
                'soup': soup,
                'webpage_body': webpage_body,
                'opening_link_company_jobs': opening_link_company_jobs
            })
                        if header and content:
                            print("-Job Description Page")
                            self.soup_elements.update({
                                'soup': soup,
                                'div_main': div_main,
                                'app_body': app_body,
                                'header': header,
                                'content': content
                            })
                            return self.job_application_webpage[0]
self.soup_elements['webpage_body']       self.soup_elements['soup']       self.soup_elements['']
'''
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!                   INDIVIDUAL COMPANY-WORKFLOW STEPS                           !
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
    #TODO: Make sure this works for when there are no links!! ALSO, maybe add a special case for "Don't see your job"/"General" application
    #def company_job_openings()
    #***
    def collect_companies_current_job_openings(self, soup, div_main, application_company_name):
        print("collect_companies_current_job_openings()")
        print("Application Company = " + application_company_name)
        current_url = self.browser.current_url
        
        if application_company_name == 'lever':
            postings_wrapper = soup.find('div', class_="postings-wrapper")
            postings_group_apply = postings_wrapper.find_all('div', class_=lambda x: x and ('postings-group' in x or 'posting-apply' in x))
            for section in postings_group_apply:
                self.init_current_jobs_details()
                print(section)
                company_department = section.find('div', class_='large-category-header').text
                if company_department:
                    print(company_department)
                if section.name == 'div' and section.get('class') == 'posting-apply':
                    job_opening_href = section.next_sibling
                    if job_opening_href.name == 'a' and job_opening_href.get('class') == 'posting-title':
                        #GET RID OF THESE???????
                        button_to_job_description = job_opening_href
                        print("button_to_job_description = ", button_to_job_description)
                        #GET RID OF THESE???????
                        job_url = self.construct_url_to_job(current_url, job_opening_href)
                        job_title = job_opening_href.find('h5').text
                        print("job_title = ", job_title)

                        if self.users_basic_requirements_job_title(job_title) == False:
                            continue
                        
                        experience_level = self.get_experience_level(job_title)

                        span_tag_location = job_opening_href.find('span', {'class', 'sort-by-location'})
                        span_tag_company_team = job_opening_href.find('span', {'class': 'sort-by-team'})
                        span_tag_workplaceType = job_opening_href.find('span', {'class': 'workplaceTypes'})

                       
                        job_location = span_tag_location.text if span_tag_location else None
                        #TODO: Find out what the heck this team is!!!
                        #company_team = span_tag_company_team.text if span_tag_company_team else None
                        job_workplaceType = span_tag_workplaceType.text if span_tag_workplaceType else None
                            
                            
                if self.check_users_basic_requirements(job_title, job_location, job_workplaceType):
                    self.current_jobs_details.update({
                        'company_department': company_department,
                        'job_url': job_url,
                        'job_title': job_title,
                        'experience_level': experience_level,
                        'job_location': job_location,
                        'job_workplaceType': job_workplaceType
                    })
                    if not experience_level:
                        self.list_of_links.append(job_url)

                self.print_companies_internal_job_opening("company_job_openings", application_company_name, JobTitle=job_title, JobLocation=job_location, WorkPlaceTypes=job_workplaceType, CompanyDepartment=company_department, JobTeamInCompany=span_tag_company_team, JobHREF=job_url, ButtonToJob=button_to_job_description)
            return
            
        elif application_company_name == 'greenhouse':
            sections = div_main.find_all('section', class_=lambda x: x and 'level' in x)
            #print(sections) #TODO: Make sure this list includes all 'level-0' and 'level-1' THEN the for loop below should parse through both 'levels'!!
            count = 0
            for section in sections:
                count += 1
                #if section.name == "class" and section.get("class") == 'level-0':
                if section.name == 'h3':
                    company_department = section.text
                    print(company_department)
                if section.name == 'h4':
                    print('This is most likely just a SUB-category so not really important other than making sure we go through EVERY job it contains!')
                    
                job_opening = section.find('div', {'class': 'opening'})
                if job_opening:
                    job_opening_href = job_opening.find('a')
                    #GET RID OF THESE???????
                    button_to_job_description = job_opening_href
                    print("button_to_job_description = ", button_to_job_description)
                    #GET RID OF THESE???????
                    if job_opening_href:
                        job_title = job_opening_href.text
                        print("job_title = ", job_title)

                        if self.users_basic_requirements_job_title(job_title) == False:
                            continue
                        
                        experience_level = self.get_experience_level(job_title)

                        job_url = self.construct_url_to_job(current_url, job_opening_href)

                        span_tag_location = job_opening.find('span', {'class', 'location'})
                        
                        job_location = span_tag_location.text if span_tag_location else None
                        print("job_location = ", job_location)
                        #job_opening_href.click()
                        
                if self.check_users_basic_requirements(job_title, job_location, job_workplaceType):
                    self.current_jobs_details.update({
                        'job_url': job_url,
                        'job_title': job_title,
                        'experience_level': experience_level,
                        'job_location': job_location,
                        'job_workplaceType': job_workplaceType
                    })
                    if not experience_level:
                        self.list_of_links.append(job_url)
                self.print_companies_internal_job_opening("company_job_openings", application_company_name, JobTitle=job_title, JobLocation=job_location, ButtonToJob=button_to_job_description)
        return
    

    def print_companies_internal_job_opening(*args, **kwargs):
        print('\n\n\n')
        print('----------------------------------------------------------------------------------------------------')
        print("print_company_job_openings()")
        method_name = None
        for arg in args:
            if arg == 'greenhouse':
                print(method_name)
                print(arg)
                for key, value in kwargs.items():
                    print(key + ": " + str(value))
            elif arg == 'lever':
                print(method_name)
                print(arg)
                for key, value in kwargs.items():
                    print(key + ": " + str(value))
            else:
                method_name = arg
        print('----------------------------------------------------------------------------------------------------')
        print('\n\n\n')
    
    #The purpose of this method is pretty much only finding and retrieving the companies' other open positions url!!!
    #TODO:   list_of_links  [ ]
    #***
    def search_for_internal_jobs_link(self):
        print("search_for_internal_jobs_link()")
        if self.application_company_name == "lever":
            print("\ngreenhouse_co_banner()")
            links_in_header = []
            print("\nThese are the links/elements that lead to this companies other available Job Openings:")
            current_url = self.browser.current_url
            print("Current URL: " + current_url)
            links_in_header.append(current_url)
            webpage_header = self.soup_elements['webpage_body'].find('div', {"class": 'main-header-content'})
            company_open_positions_a = webpage_header.find('a', {"class": "main-header-logo"})
            #! RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX
            #print("Selenium Click => Companies other Job Openings: " + company_open_positions_a)
            if isinstance(company_open_positions_a, str):
                print("Selenium Click => Companies other Job Openings: " + company_open_positions_a)
            else:
                print("Selenium Click => Companies other Job Openings: " + str(company_open_positions_a))
            #! RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX

            try:
                if company_open_positions_a['href']:
                    company_open_positions_href = company_open_positions_a['href']
                    print("Webpage's Header link: " + company_open_positions_href)
                    list_of_links = company_open_positions_href
                    print("Webpage's Header link: " + company_open_positions_href)
                    links_in_header.append(list_of_links)
            except:
                print("This company's webpage is dumb anyways! Trust me they would've probably overworked you anyways.")
            links_in_header.append(company_open_positions_a)
            self.check_banner_links(links_in_header)
            return
        
        #line 570 #elif child.name == "a"
        #if ("button" in child.get("class")) => remember !BUTTON! to click
        elif self.application_company_name == "greenhouse":
            print("\ngreenhouse_io_banner()")
            a_fragment_identifier = None
            company_other_openings_href = None
            
            first_child = True
            searched_all_a = False
            string_tab = '\n'
            for child in self.soup_elements['header'].children:
                if first_child:
                    first_child = False
                    continue
                elif child == string_tab:
                    #? continue
                    pass
                if child.name == "h1" and "app-title" in child.get("class"):
                    self.current_jobs_details["job_title"] = child.get_text().strip()
                elif child.name == "span" and  "company-name" in child.get("class"):
                    self.current_jobs_details["company_name"] = child.get_text().strip()
                elif child.name == "a" and not searched_all_a:
                    header_a_tags = self.soup_elements['header'].find_all('a')
                    for head_a_tag in header_a_tags:
                        if '/' in head_a_tag['href']:
                            company_other_openings_href = head_a_tag
                        elif '#' in head_a_tag['href']:
                            a_fragment_identifier = head_a_tag
                        elif head_a_tag == None:
                            logo_container = self.soup_elements['app_body'].find('div', class_="logo-container")
                            company_openings_a = logo_container.find('a')
                            company_other_openings_href = company_openings_a['href']
                            searched_all_a = True

                elif child.name == "div" and "location" in child.get("class"):
                    self.current_jobs_details["job_location"] = child.get_text().strip()
            if company_other_openings_href == None:
                #!!!!!!!!!!!! ERROR HANDLING !!!!!!!!!!!!
                # if a_fragment_identifier is None:
                #     a_fragment_identifier = 'Nothing here doofus!'
                #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                self.print_companies_internal_job_opening("greenhouse_io_banner()", "greenhouse", JobTitle=self.company_job_title, CompayName=self.company_name, JobLocation=self.company_job_location, JobHREF="Couldnt Find", LinkToApplication_OnPageID=a_fragment_identifier)
            else:
                self.print_companies_internal_job_opening("greenhouse_io_banner()", "greenhouse", JobTitle=self.company_job_title, CompayName=self.company_name, JobLocation=self.company_job_location, JobHREF=company_other_openings_href, LinkToApplication_OnPageID=a_fragment_identifier)
            return
            #self.greenhouse_io_content(app_body, content)
            # if a_fragment_identifier == None:
            #     return self.company_job_title, self.company_name, self.company_job_location, company_other_openings_href
            # else:
            #     return self.company_job_title, self.company_name, self.company_job_location, company_other_openings_href, a_fragment_identifier
        
        
                #         position_title = soup.find('h2')
                #         job_title = position_title.get_text().split()
                #         job_info = soup.find('div', {"class": "posting-categories"})
                #         job_location = job_info.find('div', {"class": 'location'}).get_text().strip()
                #         job_department = job_info.find('div', {"class": 'department'}).get_text().strip()
                #         job_commitment = job_info.find('div', {"class": 'commitment'}).get_text().strip()
                #         job_style = job_info.find('div', {"class": 'workplaceTypes'}).get_text().strip()
                #         print("HERE------------------------------------")
                        
                #         a_tag_butt = soup.find('a', {'data-qa': 'btn-apply-bottom'})
                #         div_tag_butt = soup.find('div', {'data-qa': 'btn-apply-bottom'})
                #         job_apply_butt = None
                #         link_to_apply = None
                #         #job_apply_butt = soup.select_one('a.btn-apply-bottom, div.btn-apply-bottom')
                #         #if job_apply_butt.name == 'div':
                #         if div_tag_butt:
                #             job_apply_butt = job_apply_butt.find('a')
                #             link_to_apply = job_apply_butt['href']
                #         elif a_tag_butt:
                #             link_to__apply = a_tag_butt['href']
                #     except:
                #         #TODO: Change this Error type!
                #         raise ConnectionError("ERROR: Companies other open positions are not present")
                # return

    



    
    #TODO: Lots of work needs to be done here!!!
    # This method is checking the links present in the header of a web page. It takes a list of
    # links as input and iterates through each link. If the link is the firstlink and the company
    # name is "lever", it tries to adjust the job link using the try_adjusting_this_link() method
    # and sets list_of_other_jobs_keyword to 'list-page'.

    # If the link is the first link and the company name is "greenhouse", it sets
    # list_of_other_jobs_keywords to an empty string and sets first_link to False. It then opens
    # each link in a new window using execute_script() method of the browser object and switches
    # to each window using switch_to.window() method.

    # For each window, it checks if list_of_other_jobs_keyword is present in the page source. If
    # it is present, it sets company_open_positions_link to the current link and returns. If
    # company_open_positions_link is still None after checking all the links, it clicks on
    # company_open_positions_a and waits for 3 seconds.
    #***
    def check_banner_links(self, links_in_header):
        print("check_banner_links()")
        #! CANT SET VALUES TO LOCAL VARIABLES  REMEMBER!!!!!...  except for booleans I guess?
        first_link = True
        list_of_other_jobs_keyword
        for header_link in links_in_header[:-1]:
            if first_link == True and "lever" == self.application_company_name:
                self.try_adjusting_this_link(header_link)    #! <- try_adjusting_this_link() returns a link!!
                list_of_other_jobs_keyword = 'list-page'
                first_link = False
            elif first_link == True and "greenhouse" in self.application_company_name:
                
                
                
                
                #self.try_adjusting_this_link(header_link)    #! <- try_adjusting_this_link() returns a link!!
                
                
                
                list_of_other_jobs_keywords = ''    #I think I just need to add a keyword here => just like lever - 'list-page'
                first_link == False
            self.browser.execute_script("window.open('{}', '_blank');".format(header_link))
            for handle in self.browser.window_handles:
                self.browser.switch_to.window(handle)
                if list_of_other_jobs_keyword in self.browser.page_source:
                    self.company_open_positions_link = header_link
                    return
        print("Hmmmm this is unexpected. I must be dumb...")
        time.sleep(1)
        print("Not like you the user; I mean me the programmer...      ", end="")
        time.sleep(1)
        print("hmmmm...")
        time.sleep(2)
        print("You probably suck too though, don't think you dont't :)")
        time.sleep(1)
        if (self.company_open_positions_link == None):
            #self.company_open_positions_a.click()
            links_in_header[-1].click()
            time.sleep(3)
            #TODO
            #!  YOU NEED TO CHECK IF IT WAS SUCCESSFUL!!!!!
            #original_link == self.browser.current_link
















































The company_workflow() method is the main driver of the CompanyOpeningsAndApplications class. It's responsible for orchestrating the process of searching for job openings at a company and handling the application process. 

















































    def handle_job_description_webpage(self):
        print("\nhandle_job_description_webpage()")
        if self.application_company_name == "lever":
            company_open_positions = self.soup_elements['soup'].find('a', {"class": "main-header-logo"})
            application_webpage_html = self.soup_elements['soup'].find("div", {"class": "application-page"})
            if not self.companys_internal_job_openings_URL:
                try:
                    self.lever_co_banner(self.soup_elements['webpage_body'], self.soup_elements['soup'])
                except:
                    raise ConnectionError("ERROR: Companies other open positions are not present")
            self.scroll_to_element(self.soup_elements['opening_link_description'])
            apply_to_job = self.should_user_apply(self.soup_elements['opening_link_description'])
            if apply_to_job:
                print("User is applying to this lever.co job!!")
                self.bottom_has_application_or_button(self.application_company_name)
                time.sleep(3)
                current_url = self.browser.current_url
                self.soup_elements['soup'] = self.apply_beautifulsoup(current_url, "html")
                self.form_input_details = self.get_form_input_details(current_url)
                self.insert_resume()
                self.process_form_inputs(self.form_input_details)
            else:
                print("\tHmmm that's weird ? it's neither button nor application")
        elif self.application_company_name == "greenhouse":
            if not self.companys_internal_job_openings_URL:
                try:
                    self.greenhouse_io_banner(self.soup_elements['app_body'], self.soup_elements['header'], self.soup_elements['content'])
                except:
                    raise ConnectionError("ERROR: Companies other open positions are not present")
            self.scroll_to_element(self.soup_elements['content'])
            current_url = self.browser.current_url
            should_apply = self

greenhouse_io_banner() and lever_co_banner()

'''
























































    def lever_io_data(self, joby_link, soup):
        self.joby_link = joby_link
        print("===Ball = inside the lever.co")
        #opening_link_application = soup.find('div', class_='page-application')      #application immediate
        opening_link_application = soup.find('div', {"class": 'application-page'})
        #opening_link_description = soup.find('div', class_='page-show')             #regular description start
        opening_link_description = soup.find('div', {"class": 'posting-page'})          #NOTE: In HTML class='one two' needs 2 class calls I think!?!?!?
        print("===Ball = opening_link_application = ", end="")
        #print(opening_link_application)
        print("You are on the Job Application webpage")
        print("===Ball = opening_link_description = ", end="")
        #print(opening_link_description)
        print("You are on the Job Description webpage")
        try:
            other_company_jobs = soup.find('div', {"class": 'page show'})
            company_open_positions = other_company_jobs.find('a', {"class": "main-header-logo"})
            if company_open_positions['href']:
                plethora_of_jobs = company_open_positions['href']
                print(plethora_of_jobs)
        except:
            print("Couldn't find the logo with the lick to plethora_of_jobs")
        
        #if soup.find('a', class_='main-header-logo'):
        if opening_link_application:
            try:
                company_open_positions = soup.find('a', {"class": "main-header-logo"})
                #company_open_positions = soup.find('a', class_=['main-header-logo', 'main-header'])
                plethora_of_jobs = company_open_positions['href']
                print("===Ball = plethora_of_jobs = ", end="")
                print(plethora_of_jobs)
                application_webpage_html = soup.find("div", {"class": "application-page"})
                self.lever_io_application(joby_link, application_webpage_html)
                #return opening_link_application
            except:
                #TODO: Change this Error type!
                raise ConnectionError("ERROR: Companies other open positions are not present")
        elif opening_link_description:
            print("===Ball = lever.co is working")
            try:
                print("===Ball = inside the try lever.co")
                position_title = soup.find('h2')
                job_title = position_title.get_text().split()
                print("===Ball = job_title = ", end="")
                #print(job_title.get_text())
                print(job_title)
                #? .position_title.find() doesn't work b/c the <h2> and <div> are siblings!!
                # job_info = position_title.find('div', {"class": "posting-categories"})
                job_info = soup.find('div', {"class": "posting-categories"})
                job_location = job_info.find('div', {"class": 'location'}).get_text().strip()
                job_department = job_info.find('div', {"class": 'department'}).get_text().strip()
                job_commitment = job_info.find('div', {"class": 'commitment'}).get_text().strip()
                job_style = job_info.find('div', {"class": 'workplaceTypes'}).get_text().strip()
                print("HERE------------------------------------")
                print(job_location)
        
                a_tag_butt = soup.find('a', {'data-qa': 'btn-apply-bottom'})
                div_tag_butt = soup.find('div', {'data-qa': 'btn-apply-bottom'})
                job_apply_butt = None
                link_to_apply = None
                #job_apply_butt = soup.select_one('a.btn-apply-bottom, div.btn-apply-bottom')
                #if job_apply_butt.name == 'div':
                if div_tag_butt:
                    job_apply_butt = job_apply_butt.find('a')
                    link_to_apply = job_apply_butt['href']
                elif a_tag_butt:
                    link_to_apply = a_tag_butt['href']
                
                print("===Ball = link_to_apply = ", end="")
                print(link_to_apply)

            except:
                #TODO: Change this Error type!
                raise ConnectionError("ERROR: Companies other open positions are not present")
        #print("===Ball = leaving the lever.co")
        return soup

    def determine_current_page(self, job_link, application_company_name):
        print("determine_current_page()")
        soup = self.apply_beautifulsoup(job_link, "lxml")
        print("\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
        if application_company_name == "lever":
            webpage_body = soup.find('body')
            opening_link_application = soup.find('div', {"class": 'application-page'})
            opening_link_description = soup.find('div', {"class": 'posting-page'})
            opening_link_company_jobs = soup.find('div', {"class": "list-page"})
            if opening_link_application:
                print('-Application Page')
                try:
                    #TODO: This is v what we want to avoid!!!
                    company_open_positions = soup.find('a', {"class": "main-header-logo"})
                    application_webpage_html = soup.find("div", {"class": "application-page"})
                    self.lever_co_header(webpage_body, soup)
                    #!xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                    self.form_input_details = self.get_form_input_details(current_url)
                    self.process_form_inputs(self.form_input_details)
                    
                    
                    #!xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                #     try:
                #         self.company_open_positions_a.click()
                #     except:
                #         raw_link = company_open_positions['href']
                #         self.browser.get(raw_link)
                #     time.sleep(2)
                #     return
                except:
                    #TODO: Change this Error type!
                    raise ConnectionError("ERROR: Companies other open positions are not present")
            elif opening_link_description:
                print("-Job Description Page")
                self.scroll_to_element(opening_link_description)
                apply_to_job = self.should_user_apply(opening_link_description)
                if apply_to_job == True:
                    print("lever application locked and loaded")
                    self.bottom_has_application_or_button(application_company_name)
                    time.sleep(3)
                    current_url = self.browser.current_url
                    soup = self.apply_beautifulsoup(current_url, "html")
                    self.form_input_details = self.get_form_input_details(current_url)
                    self.insert_resume()
                    #!xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                    #self.form_input_details = self.get_form_input_details(current_url)
                    self.process_form_inputs(self.form_input_details)
                    
                    
                    #!xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                    #self.fill_out_application(job_link, form_input_details)
                    self.keep_jobs_applied_to_info()
                elif not apply_to_job:
                    #TODO:
                    self.company_other_openings_href.click()
                    
                #TODO: If the button is present click OTHERWISE just insert the link
                if self.company_other_openings_href:
                    self.company_other_openings_href.click()
                else:
                    self.browser.get(self.company_other_openings_href)

            elif opening_link_company_jobs:
                print('-Job Listings Page')
                pass
            return

    def collect_companies_current_job_openings(self, soup, div_main, application_company_name):
        print("collect_companies_current_job_openings()")
        print("Application Company = " + application_company_name)
        current_url = self.browser.current_url
        
        if application_company_name == 'lever':
            postings_wrapper = soup.find('div', class_="postings-wrapper")
            postings_group_apply = postings_wrapper.find_all('div', class_=lambda x: x and ('postings-group' in x or 'posting-apply' in x))
            for section in postings_group_apply:
                self.init_current_jobs_details()
                print(section)
                company_department = section.find('div', class_='large-category-header').text
                if company_department:
                    print(company_department)
                if section.name == 'div' and section.get('class') == 'posting-apply':
                    job_opening_href = section.next_sibling
                    if job_opening_href.name == 'a' and job_opening_href.get('class') == 'posting-title':
                        #GET RID OF THESE???????
                        button_to_job_description = job_opening_href
                        print("button_to_job_description = ", button_to_job_description)
                        #GET RID OF THESE???????
                        job_url = self.construct_url_to_job(current_url, job_opening_href)
                        job_title = job_opening_href.find('h5').text
                        print("job_title = ", job_title)

                        if self.users_basic_requirements_job_title(job_title) == False:
                            continue
                        
                        experience_level = self.get_experience_level(job_title)

                        span_tag_location = job_opening_href.find('span', {'class', 'sort-by-location'})
                        span_tag_company_team = job_opening_href.find('span', {'class': 'sort-by-team'})
                        span_tag_workplaceType = job_opening_href.find('span', {'class': 'workplaceTypes'})

                       
                        job_location = span_tag_location.text if span_tag_location else None
                        #TODO: Find out what the heck this team is!!!
                        #company_team = span_tag_company_team.text if span_tag_company_team else None
                        job_workplaceType = span_tag_workplaceType.text if span_tag_workplaceType else None
                            
                            
                if self.check_users_basic_requirements(job_title, job_location, job_workplaceType):
                    self.current_jobs_details.update({
                        'company_department': company_department,
                        'job_url': job_url,
                        'job_title': job_title,
                        'experience_level': experience_level,
                        'job_location': job_location,
                        'job_workplaceType': job_workplaceType
                    })
                    if not experience_level:
                        self.list_of_links.append(job_url)

                self.print_companies_internal_job_opening("company_job_openings", application_company_name, JobTitle=job_title, JobLocation=job_location, WorkPlaceTypes=job_workplaceType, CompanyDepartment=company_department, JobTeamInCompany=span_tag_company_team, JobHREF=job_url, ButtonToJob=button_to_job_description)
            return

    def search_for_internal_jobs_link(self):
        print("search_for_internal_jobs_link()")
        if self.application_company_name == "lever":
            print("\ngreenhouse_co_banner()")
            links_in_header = []
            print("\nThese are the links/elements that lead to this companies other available Job Openings:")
            current_url = self.browser.current_url
            print("Current URL: " + current_url)
            links_in_header.append(current_url)
            webpage_header = self.soup_elements['webpage_body'].find('div', {"class": 'main-header-content'})
            company_open_positions_a = webpage_header.find('a', {"class": "main-header-logo"})
            #! RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX
            #print("Selenium Click => Companies other Job Openings: " + company_open_positions_a)
            if isinstance(company_open_positions_a, str):
                print("Selenium Click => Companies other Job Openings: " + company_open_positions_a)
            else:
                print("Selenium Click => Companies other Job Openings: " + str(company_open_positions_a))
            #! RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX RECENT FIX

            try:
                if company_open_positions_a['href']:
                    company_open_positions_href = company_open_positions_a['href']
                    print("Webpage's Header link: " + company_open_positions_href)
                    list_of_links = company_open_positions_href
                    print("Webpage's Header link: " + company_open_positions_href)
                    links_in_header.append(list_of_links)
            except:
                print("This company's webpage is dumb anyways! Trust me they would've probably overworked you anyways.")
            links_in_header.append(company_open_positions_a)
            self.check_banner_links(links_in_header)
            return



    def bottom_has_application_or_button(self, application_company_name):
        print("bottom_has_application_or_button()")
        soup = self.apply_beautifulsoup(self.browser.current_url, "html")
        if application_company_name == "lever":
            a_tag_butt = soup.find('a', {'data-qa': ['btn-apply-bottom', 'show-page-apply']})
            div_tag_butt = soup.find('div', {'data-qa': 'btn-apply-bottom'})
            application_at_bottom = soup.find("div", id="application")
            print("\nLever: Application at bottom or <button>")
            if a_tag_butt:
                print("\tPress button to go to application")
                xpath_selector = f"//a[@data-qa='{a_tag_butt['data-qa']}']"
                print(f"xpath_selector: {xpath_selector}")
                apply_button = self.browser.find_element(By.XPATH, xpath_selector)
                self.scroll_to_element(apply_button)
                time.sleep(1)
                print("apply_button: ", end="")
                print(apply_button)
                apply_button.click()
                time.sleep(2)
            elif div_tag_butt:
                print("\tlever: Press button to go to application")
                apply_button = self.browser.find_element(By.XPATH, f"//div[@data-qa='{a_tag_butt['data-qa'][0]}']")
                self.scroll_to_element(apply_button)
                time.sleep(1)
                apply_button.click()
                time.sleep(3)
            elif application_at_bottom:
                print("\tApplication at bottom of page")
                self.scroll_to_element(application_at_bottom)
            return






































class CompanyWorkflow():

    def __init__(self, JobSearchWorkflow_instance, browser, users_information, init_users_job_search_requirements, jobs_applied_to_this_session, tokenizer, model, nlp, lemmatizer, custom_rules, q_and_a, custom_synonyms):
        if JobSearchWorkflow_instance is None or browser is None:
            raise ValueError("JobSearchWorkflow_instance and browser cannot be None.")
        
        self.JobSearchWorkflow_instance = JobSearchWorkflow_instance
        self.browser = browser
        self.current_url = None
        self.list_of_links = []
        self.users_information = users_information
        self.init_users_job_search_requirements = init_users_job_search_requirements
        self.application_company_name = None
        self.companys_internal_job_openings_URL = None
        self.prior_experience_keywords = ["senior", "sr", "principal", "lead", "manager"]
        self.jobs_applied_to_this_session = jobs_applied_to_this_session
        self.one_resume_label = False
        self.form_input_details = {}
        self.form_input_extended = None
        self.tokenizer = tokenizer
        self.model = model
        self.nlp = nlp
        self.lemmatizer = lemmatizer
        self.custom_rules = custom_rules
        self.q_and_a = q_and_a
        self.custom_synonyms = custom_synonyms
        self.env_path = '.env'
        self.job_application_webpage = ["Internal-Job-Listings", "Job-Description", "Job-Application", "Submitted-Application"]
        self.soup_elements = {}
        self.variable_elements = {}
        self.current_jobs_details = {}
        self.website_data = {}

    def reset_webpages_soup_elements(self):
        self.soup_elements = {}

    def reset_webpages_variable_elements(self):
        self.variable_elements = {}

    def init_current_jobs_details(self):
        self.current_jobs_details = {
            "job_url": None,
            "job_title": None,
            "job_location": None,
            "company_name": None,
            "job_workplaceType": None,
            "company_department": None,
            "job_id_number": None,
            "job_release_date": None,
            "employment_type": None,
            "experience_level": None,
            "years_of_experience": None,
            "company_industry": None,
        }
        
    def keep_jobs_applied_to_info(self):
        self.jobs_applied_to_this_session.append(self.current_jobs_details)
    
    def reset_every_job_variable(self):
        self.init_current_jobs_details()
        self.reset_webpages_soup_elements()
        self.reset_webpages_variable_elements()
        self.form_input_details = {}
        self.form_input_extended = None

    def apply_beautifulsoup(self, job_link, parser):
        print("\napply_beautifulsoup()")
        if parser == "lxml":
            result = requests.get(job_link)
            content = result.text
            soup = BeautifulSoup(content, "lxml")
        elif parser == "html":
            page = requests.get(job_link)
            result = page.content
            soup = BeautifulSoup(result, "html.parser")           
        return soup

    def update_soup_elements(self, soup, **kwargs):
        self.soup_elements.update({'soup': soup, **kwargs})
----
    def get_website_data(self):
        with open('website_elements.json') as websites_data_json_file:
            data = json.load(websites_data_json_file)
            return data.get(self.application_company_name, None)

    #This method is used extract a specified values's/webpage(self.job_application_webpage(#) == self.website_data) from self.website_data
    def get_webpage_data(self, job_application_webpage):
        return self.website_data.get(job_application_webpage, None)

    #"Extracts a specified webpage from self.website_data" and then "extracts it's elements" to begin the
    #process of adjusting for a new webpage; which then leads us to shuffling through all the "elements
    #values" and ?key-value pairs?, it uses the element_name as the key value name for self.soup_elements
    #then shuffles through element_info sets
    def process_webpage(self, job_application_webpage):
        if not self.website_data:
            self.get_website_data()
        webpage_elements = self.get_webpage_data(job_application_webpage)

        # Process each element defined in the page info.
        for element_name, element_info in webpage_elements["elements"].items():
            for element_details in element_info:
                element = self.soup_elements['soup'].find(element_details["tag"], **{element_details.get("attr"): element_details.get("value")})
                if element:
                    self.update_soup_elements(self.soup_elements['soup'], **{element_name: element})
                    #This is supposed to be here figure out why!
                    break

        return

    def job_description_webpage_navigation(self):
        print("\njob_description_webpage_navigation()")
        print("Welcome fair maiden!")
        self.process_webpage(self.job_application_webpage[1])
        if self.application_company_name == "lever":
            print("The Noble Man")
            next_elem = self.soup_elements['banner_job_info']
            while next_elem:
              if (job_title := next_elem.get_text().strip()) and next_elem.name == "h2":
                self.current_jobs_details["job_title"] = job_title
              if next_elem.name == "div" and next_elem.get("class") == "location" and (job_location := next_elem.get_text().strip()):
                self.current_jobs_details["job_location"] = job_location
              if next_elem.name == "div" and next_elem.get("class") == "department" and (company_department := next_elem.get_text().strip()):
                self.current_jobs_details["company_department"] = company_department
              if next_elem.name == "div" and next_elem.get("class") == "commitment" and (employment_type := next_elem.get_text().strip()):
                self.current_jobs_details["employment_type"] = employment_type
              if next_elem.name == "div" and next_elem.get("class") == "workplaceTypes" and (job_workplaceType := next_elem.get_text().strip()):
                self.current_jobs_details["job_workplaceType"] = workplaceTypes
              next_elem = next_elem.find_next()
        elif self.application_company_name == "greenhouse":
            #TODO: These need to be called and set earlier!!! BEFORE self.process_webpage(self.job_application_webpage[1]) IS CALLED!!!!
            #self.soup_elements['soup'] = self.apply_beautifulsoup(self.current_url, 'html.parser')
            #self.soup_elements['div_main'] = self.soup_elements['soup'].find("div", id="main")
            
            next_elem = self.soup_elements['div_main'].find_next()

            while next_elem:
                #This if statement should test the identifiable/unique element that represents that was are in fact on the "Job-Description" page!!
                  #Ex. For "greenhouse" that would be - (next_elem.name == "div" and next_elem.get("id") in ["app-body", "app_body"])
                #!!! This is literally the purpose determine_current_page() !!!
                if self.application_company_name == "greenhouse" and self.soup_elements["app_body]:
                    if 'header' in self.soup_elements and 'content' in self.soup_elements:
                          header = self.soup_elements['header']
                          content = self.soup_elements['content']

                          if job_title_elem := header.find("h1", class_="app-title").get_text().strip():
                              self.current_jobs_details["job_title"] = job_title_elem

                          # Extract company name
                          if company_name_elem := header.find("span", class_="company-name").get_text().strip():
                              self.current_jobs_details["company_name"] = company_name_elem

                          # Extract job location
                          if job_location_elem := header.find("div", class_="location").get_text().strip():
                              self.current_jobs_details["job_location"] = job_location_elem
                      else:
                          print("Guess the .greenhouse_io_start_page_detector() while loop doesn't work")
                  elif self.application_company_name == "lever" and self.soup_elements["app_body]:
                    if 'header' in self.soup_elements and 'content' in self.soup_elements:
                next_elem = next_elem.find_next()








































































































































































































































































































































































































































































































































































































































































































